// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: graph.proto
#pragma warning disable 1591, 0612, 3021
#region Designer generated code

using pb = global::Google.Protobuf;
using pbc = global::Google.Protobuf.Collections;
using pbr = global::Google.Protobuf.Reflection;
using scg = global::System.Collections.Generic;
namespace LotusIR {

  /// <summary>Holder for reflection information generated from graph.proto</summary>
  public static partial class GraphReflection {

    #region Descriptor
    /// <summary>File descriptor for graph.proto</summary>
    public static pbr::FileDescriptor Descriptor {
      get { return descriptor; }
    }
    private static pbr::FileDescriptor descriptor;

    static GraphReflection() {
      byte[] descriptorData = global::System.Convert.FromBase64String(
          string.Concat(
            "CgtncmFwaC5wcm90bxIHTG90dXNJUiKpAwoOQXR0cmlidXRlUHJvdG8SDAoE",
            "bmFtZRgBIAEoCRIJCgFmGAIgASgCEgkKAWkYAyABKAMSCQoBcxgEIAEoDBIf",
            "CgF0GAUgASgLMhQuTG90dXNJUi5UZW5zb3JQcm90bxIeCgFnGAYgASgLMhMu",
            "TG90dXNJUi5HcmFwaFByb3RvEg4KBmZsb2F0cxgHIAMoAhIMCgRpbnRzGAgg",
            "AygDEg8KB3N0cmluZ3MYCSADKAwSJQoHdGVuc29ycxgKIAMoCzIULkxvdHVz",
            "SVIuVGVuc29yUHJvdG8SIwoGZ3JhcGhzGAsgAygLMhMuTG90dXNJUi5HcmFw",
            "aFByb3RvEiAKBHR5cGUYMyABKAsyEi5Mb3R1c0lSLlR5cGVQcm90bxIhCgV0",
            "eXBlcxg0IAMoCzISLkxvdHVzSVIuVHlwZVByb3RvEjIKBXNoYXBlGDUgASgL",
            "MiMuTG90dXNJUi5UeXBlUHJvdG8uVGVuc29yU2hhcGVQcm90bxIzCgZzaGFw",
            "ZXMYNiADKAsyIy5Mb3R1c0lSLlR5cGVQcm90by5UZW5zb3JTaGFwZVByb3Rv",
            "IlQKDlZhbHVlSW5mb1Byb3RvEgwKBG5hbWUYASABKAkSIAoEdHlwZRgCIAEo",
            "CzISLkxvdHVzSVIuVHlwZVByb3RvEhIKCmRvY19zdHJpbmcYAyABKAkiwAEK",
            "CU5vZGVQcm90bxINCgVpbnB1dBgBIAMoCRIOCgZvdXRwdXQYAiADKAkSDAoE",
            "bmFtZRgDIAEoCRIPCgdvcF90eXBlGAQgASgJEioKCWF0dHJpYnV0ZRgFIAMo",
            "CzIXLkxvdHVzSVIuQXR0cmlidXRlUHJvdG8SEgoKZG9jX3N0cmluZxgGIAEo",
            "CRIXCg9pbnB1dF9hcmdfY291bnQYMiADKAUSFQoNY29udHJvbF9pbnB1dBgz",
            "IAMoCUoFCGQQyQEi6gEKCk1vZGVsUHJvdG8SEgoKaXJfdmVyc2lvbhgBIAEo",
            "AxIVCg1wcm9kdWNlcl9uYW1lGAIgASgJEhgKEHByb2R1Y2VyX3ZlcnNpb24Y",
            "AyABKAkSDgoGZG9tYWluGAQgASgJEhUKDW1vZGVsX3ZlcnNpb24YBSABKAMS",
            "EgoKZG9jX3N0cmluZxgGIAEoCRIiCgVncmFwaBgHIAEoCzITLkxvdHVzSVIu",
            "R3JhcGhQcm90bxIUCgxtb2RlbF9hdXRob3IYMiABKAkSFQoNbW9kZWxfbGlj",
            "ZW5zZRgzIAEoCUoECAgQMkoFCGQQyQEi9wIKCkdyYXBoUHJvdG8SIAoEbm9k",
            "ZRgBIAMoCzISLkxvdHVzSVIuTm9kZVByb3RvEgwKBG5hbWUYAiABKAkSKQoL",
            "aW5pdGlhbGl6ZXIYBSADKAsyFC5Mb3R1c0lSLlRlbnNvclByb3RvEhIKCmRv",
            "Y19zdHJpbmcYCiABKAkSJgoFaW5wdXQYCyADKAsyFy5Mb3R1c0lSLlZhbHVl",
            "SW5mb1Byb3RvEicKBm91dHB1dBgMIAMoCzIXLkxvdHVzSVIuVmFsdWVJbmZv",
            "UHJvdG8SKwoKdmFsdWVfaW5mbxgNIAMoCzIXLkxvdHVzSVIuVmFsdWVJbmZv",
            "UHJvdG8SKwoIZnVuY3Rpb24YMiADKAsyGS5Mb3R1c0lSLkZ1bmN0aW9uRGVm",
            "UHJvdG8SLAoIb3BlcmF0b3IYMyADKAsyGi5Mb3R1c0lSLk9wZXJhdG9yRGVj",
            "bFByb3RvEhoKEmltcG9ydGVkX2xpYnJhcmllcxg0IAMoCUoFCGQQyQEioQQK",
            "C1RlbnNvclByb3RvEgwKBGRpbXMYASADKAMSMAoJZGF0YV90eXBlGAIgASgO",
            "Mh0uTG90dXNJUi5UZW5zb3JQcm90by5EYXRhVHlwZRItCgdzZWdtZW50GAMg",
            "ASgLMhwuTG90dXNJUi5UZW5zb3JQcm90by5TZWdtZW50EhYKCmZsb2F0X2Rh",
            "dGEYBCADKAJCAhABEhYKCmludDMyX2RhdGEYBSADKAVCAhABEhMKC3N0cmlu",
            "Z19kYXRhGAYgAygMEhYKCmludDY0X2RhdGEYByADKANCAhABEgwKBG5hbWUY",
            "CCABKAkSEAoIcmF3X2RhdGEYCSABKAwSFwoLZG91YmxlX2RhdGEYCiADKAFC",
            "AhABEhcKC3VpbnQ2NF9kYXRhGAsgAygEQgIQARolCgdTZWdtZW50Eg0KBWJl",
            "Z2luGAEgASgDEgsKA2VuZBgCIAEoAyLMAQoIRGF0YVR5cGUSDQoJVU5ERUZJ",
            "TkVEEAASCQoFRkxPQVQQARIJCgVVSU5UOBACEggKBElOVDgQAxIKCgZVSU5U",
            "MTYQBBIJCgVJTlQxNhAFEgkKBUlOVDMyEAYSCQoFSU5UNjQQBxIKCgZTVFJJ",
            "TkcQCBIICgRCT09MEAkSCwoHRkxPQVQxNhAKEgoKBkRPVUJMRRALEgoKBlVJ",
            "TlQzMhAMEgoKBlVJTlQ2NBANEg0KCUNPTVBMRVg2NBAOEg4KCkNPTVBMRVgx",
            "MjgQDyJuChFTcGFyc2VUZW5zb3JQcm90bxIMCgRkaW1zGAEgAygDEiUKB2lu",
            "ZGljZXMYAiABKAsyFC5Mb3R1c0lSLlRlbnNvclByb3RvEiQKBnZhbHVlcxgD",
            "IAEoCzIULkxvdHVzSVIuVGVuc29yUHJvdG8i/AcKCVR5cGVQcm90bxI5Cgt0",
            "ZW5zb3JfdHlwZRgBIAEoCzIiLkxvdHVzSVIuVHlwZVByb3RvLlRlbnNvclR5",
            "cGVQcm90b0gAEkYKEnNwYXJzZV90ZW5zb3JfdHlwZRgCIAEoCzIoLkxvdHVz",
            "SVIuVHlwZVByb3RvLlNwYXJzZVRlbnNvclR5cGVQcm90b0gAEjkKC2hhbmRs",
            "ZV90eXBlGAMgASgLMiIuTG90dXNJUi5UeXBlUHJvdG8uSGFuZGxlVHlwZVBy",
            "b3RvSAASNwoKdHVwbGVfdHlwZRgEIAEoCzIhLkxvdHVzSVIuVHlwZVByb3Rv",
            "LlR1cGxlVHlwZVByb3RvSAASMwoIc2VxX3R5cGUYBSABKAsyHy5Mb3R1c0lS",
            "LlR5cGVQcm90by5TZXFUeXBlUHJvdG9IABIzCghtYXBfdHlwZRgGIAEoCzIf",
            "LkxvdHVzSVIuVHlwZVByb3RvLk1hcFR5cGVQcm90b0gAGo4BChBUZW5zb3JT",
            "aGFwZVByb3RvEjoKA2RpbRgBIAMoCzItLkxvdHVzSVIuVHlwZVByb3RvLlRl",
            "bnNvclNoYXBlUHJvdG8uRGltZW5zaW9uGj4KCURpbWVuc2lvbhITCglkaW1f",
            "dmFsdWUYASABKANIABITCglkaW1fcGFyYW0YAiABKAlIAEIHCgV2YWx1ZRp3",
            "Cg9UZW5zb3JUeXBlUHJvdG8SMAoJZWxlbV90eXBlGAEgASgOMh0uTG90dXNJ",
            "Ui5UZW5zb3JQcm90by5EYXRhVHlwZRIyCgVzaGFwZRgCIAEoCzIjLkxvdHVz",
            "SVIuVHlwZVByb3RvLlRlbnNvclNoYXBlUHJvdG8afQoVU3BhcnNlVGVuc29y",
            "VHlwZVByb3RvEjAKCWVsZW1fdHlwZRgBIAEoDjIdLkxvdHVzSVIuVGVuc29y",
            "UHJvdG8uRGF0YVR5cGUSMgoFc2hhcGUYAiABKAsyIy5Mb3R1c0lSLlR5cGVQ",
            "cm90by5UZW5zb3JTaGFwZVByb3RvGhEKD0hhbmRsZVR5cGVQcm90bxo3Cg5U",
            "dXBsZVR5cGVQcm90bxIlCgllbGVtX3R5cGUYASADKAsyEi5Mb3R1c0lSLlR5",
            "cGVQcm90bxo1CgxTZXFUeXBlUHJvdG8SJQoJZWxlbV90eXBlGAEgASgLMhIu",
            "TG90dXNJUi5UeXBlUHJvdG8acgoMTWFwVHlwZVByb3RvEi8KCGtleV90eXBl",
            "GAEgASgOMh0uTG90dXNJUi5UZW5zb3JQcm90by5EYXRhVHlwZRIxCgp2YWx1",
            "ZV90eXBlGAIgASgOMh0uTG90dXNJUi5UZW5zb3JQcm90by5EYXRhVHlwZUIH",
            "CgV2YWx1ZUoFCGQQyQEimwQKClZhbHVlUHJvdG8SLAoMZGVuc2VfdGVuc29y",
            "GAEgASgLMhQuTG90dXNJUi5UZW5zb3JQcm90b0gAEjMKDXNwYXJzZV90ZW5z",
            "b3IYAiABKAsyGi5Mb3R1c0lSLlNwYXJzZVRlbnNvclByb3RvSAASMQoGaGFu",
            "ZGxlGAMgASgLMh8uTG90dXNJUi5WYWx1ZVByb3RvLkhhbmRsZVByb3RvSAAS",
            "LwoFdHVwbGUYBCABKAsyHi5Mb3R1c0lSLlZhbHVlUHJvdG8uVHVwbGVQcm90",
            "b0gAEjAKA3NlcRgFIAEoCzIhLkxvdHVzSVIuVmFsdWVQcm90by5TZXF1ZW5j",
            "ZVByb3RvSAASKwoDbWFwGAYgASgLMhwuTG90dXNJUi5WYWx1ZVByb3RvLk1h",
            "cFByb3RvSAAaGgoLSGFuZGxlUHJvdG8SCwoDdWlkGAEgASgDGjAKClR1cGxl",
            "UHJvdG8SIgoFZWxlbXMYASADKAsyEy5Mb3R1c0lSLlZhbHVlUHJvdG8aMwoN",
            "U2VxdWVuY2VQcm90bxIiCgVlbGVtcxgBIAMoCzITLkxvdHVzSVIuVmFsdWVQ",
            "cm90bxpUCghNYXBQcm90bxIiCgRrZXlzGAEgASgLMhQuTG90dXNJUi5UZW5z",
            "b3JQcm90bxIkCgZ2YWx1ZXMYAiABKAsyFC5Mb3R1c0lSLlRlbnNvclByb3Rv",
            "QgcKBXZhbHVlSgUIZBDJASJYChJQYXJhbWV0ZXJEZWNsUHJvdG8SDAoEbmFt",
            "ZRgBIAEoCRIgCgR0eXBlGAIgASgLMhIuTG90dXNJUi5UeXBlUHJvdG8SEgoK",
            "ZG9jX3N0cmluZxgDIAEoCSLrAQoQRnVuY3Rpb25EZWZQcm90bxIMCgRuYW1l",
            "GAEgASgJEjEKDGlucHV0X3BhcmFtcxgCIAMoCzIbLkxvdHVzSVIuUGFyYW1l",
            "dGVyRGVjbFByb3RvEjIKDW91dHB1dF9wYXJhbXMYAyADKAsyGy5Mb3R1c0lS",
            "LlBhcmFtZXRlckRlY2xQcm90bxIgCgRub2RlGAQgAygLMhIuTG90dXNJUi5O",
            "b2RlUHJvdG8SJQoEYXR0chgFIAMoCzIXLkxvdHVzSVIuQXR0cmlidXRlUHJv",
            "dG8SEgoKZG9jX3N0cmluZxgGIAEoCUoFCGQQyQEixgEKElNpZ25hdHVyZURl",
            "Y2xQcm90bxIxCgxpbnB1dF9wYXJhbXMYASADKAsyGy5Mb3R1c0lSLlBhcmFt",
            "ZXRlckRlY2xQcm90bxIyCg1vdXRwdXRfcGFyYW1zGAIgAygLMhsuTG90dXNJ",
            "Ui5QYXJhbWV0ZXJEZWNsUHJvdG8SNQoQaW5wdXRfYXR0cmlidXRlcxgDIAMo",
            "CzIbLkxvdHVzSVIuUGFyYW1ldGVyRGVjbFByb3RvEhIKCmRvY19zdHJpbmcY",
            "BCABKAkibAoRT3BlcmF0b3JEZWNsUHJvdG8SDAoEbmFtZRgBIAEoCRIuCglz",
            "aWduYXR1cmUYAiADKAsyGy5Mb3R1c0lSLlNpZ25hdHVyZURlY2xQcm90bxIS",
            "Cgpkb2Nfc3RyaW5nGAMgASgJSgUIZBDJASLGAgoMTGlicmFyeVByb3RvEhIK",
            "CmlyX3ZlcnNpb24YASABKAMSGAoQcHJvZHVjZXJfdmVyc2lvbhgCIAEoAxIU",
            "Cgxwcm9kdWNlcl90YWcYAyABKAkSFQoNbW9kZWxfdmVyc2lvbhgEIAEoAxIU",
            "Cgxtb2RlbF9hdXRob3IYBSABKAkSFQoNbW9kZWxfbGljZW5zZRgGIAEoCRIM",
            "CgRuYW1lGAcgASgJEg4KBmRvbWFpbhgIIAEoCRISCgpkb2Nfc3RyaW5nGAkg",
            "ASgJEiwKCG9wZXJhdG9yGAogAygLMhouTG90dXNJUi5PcGVyYXRvckRlY2xQ",
            "cm90bxIrCghmdW5jdGlvbhgLIAMoCzIZLkxvdHVzSVIuRnVuY3Rpb25EZWZQ",
            "cm90bxIaChJpbXBvcnRlZF9saWJyYXJpZXMYDCADKAlKBQhkEMkBKiMKB1Zl",
            "cnNpb24SCAoETk9ORRAAEg4KCklSX1ZFUlNJT04QAWIGcHJvdG8z"));
      descriptor = pbr::FileDescriptor.FromGeneratedCode(descriptorData,
          new pbr::FileDescriptor[] { },
          new pbr::GeneratedClrTypeInfo(new[] {typeof(global::LotusIR.Version), }, new pbr::GeneratedClrTypeInfo[] {
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.AttributeProto), global::LotusIR.AttributeProto.Parser, new[]{ "Name", "F", "I", "S", "T", "G", "Floats", "Ints", "Strings", "Tensors", "Graphs", "Type", "Types_", "Shape", "Shapes" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.ValueInfoProto), global::LotusIR.ValueInfoProto.Parser, new[]{ "Name", "Type", "DocString" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.NodeProto), global::LotusIR.NodeProto.Parser, new[]{ "Input", "Output", "Name", "OpType", "Attribute", "DocString", "InputArgCount", "ControlInput" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.ModelProto), global::LotusIR.ModelProto.Parser, new[]{ "IrVersion", "ProducerName", "ProducerVersion", "Domain", "ModelVersion", "DocString", "Graph", "ModelAuthor", "ModelLicense" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.GraphProto), global::LotusIR.GraphProto.Parser, new[]{ "Node", "Name", "Initializer", "DocString", "Input", "Output", "ValueInfo", "Function", "Operator", "ImportedLibraries" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TensorProto), global::LotusIR.TensorProto.Parser, new[]{ "Dims", "DataType", "Segment", "FloatData", "Int32Data", "StringData", "Int64Data", "Name", "RawData", "DoubleData", "Uint64Data" }, null, new[]{ typeof(global::LotusIR.TensorProto.Types.DataType) }, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TensorProto.Types.Segment), global::LotusIR.TensorProto.Types.Segment.Parser, new[]{ "Begin", "End" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.SparseTensorProto), global::LotusIR.SparseTensorProto.Parser, new[]{ "Dims", "Indices", "Values" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TypeProto), global::LotusIR.TypeProto.Parser, new[]{ "TensorType", "SparseTensorType", "HandleType", "TupleType", "SeqType", "MapType" }, new[]{ "Value" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TypeProto.Types.TensorShapeProto), global::LotusIR.TypeProto.Types.TensorShapeProto.Parser, new[]{ "Dim" }, null, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TypeProto.Types.TensorShapeProto.Types.Dimension), global::LotusIR.TypeProto.Types.TensorShapeProto.Types.Dimension.Parser, new[]{ "DimValue", "DimParam" }, new[]{ "Value" }, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TypeProto.Types.TensorTypeProto), global::LotusIR.TypeProto.Types.TensorTypeProto.Parser, new[]{ "ElemType", "Shape" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TypeProto.Types.SparseTensorTypeProto), global::LotusIR.TypeProto.Types.SparseTensorTypeProto.Parser, new[]{ "ElemType", "Shape" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TypeProto.Types.HandleTypeProto), global::LotusIR.TypeProto.Types.HandleTypeProto.Parser, null, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TypeProto.Types.TupleTypeProto), global::LotusIR.TypeProto.Types.TupleTypeProto.Parser, new[]{ "ElemType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TypeProto.Types.SeqTypeProto), global::LotusIR.TypeProto.Types.SeqTypeProto.Parser, new[]{ "ElemType" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.TypeProto.Types.MapTypeProto), global::LotusIR.TypeProto.Types.MapTypeProto.Parser, new[]{ "KeyType", "ValueType" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.ValueProto), global::LotusIR.ValueProto.Parser, new[]{ "DenseTensor", "SparseTensor", "Handle", "Tuple", "Seq", "Map" }, new[]{ "Value" }, null, new pbr::GeneratedClrTypeInfo[] { new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.ValueProto.Types.HandleProto), global::LotusIR.ValueProto.Types.HandleProto.Parser, new[]{ "Uid" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.ValueProto.Types.TupleProto), global::LotusIR.ValueProto.Types.TupleProto.Parser, new[]{ "Elems" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.ValueProto.Types.SequenceProto), global::LotusIR.ValueProto.Types.SequenceProto.Parser, new[]{ "Elems" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.ValueProto.Types.MapProto), global::LotusIR.ValueProto.Types.MapProto.Parser, new[]{ "Keys", "Values" }, null, null, null)}),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.ParameterDeclProto), global::LotusIR.ParameterDeclProto.Parser, new[]{ "Name", "Type", "DocString" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.FunctionDefProto), global::LotusIR.FunctionDefProto.Parser, new[]{ "Name", "InputParams", "OutputParams", "Node", "Attr", "DocString" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.SignatureDeclProto), global::LotusIR.SignatureDeclProto.Parser, new[]{ "InputParams", "OutputParams", "InputAttributes", "DocString" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.OperatorDeclProto), global::LotusIR.OperatorDeclProto.Parser, new[]{ "Name", "Signature", "DocString" }, null, null, null),
            new pbr::GeneratedClrTypeInfo(typeof(global::LotusIR.LibraryProto), global::LotusIR.LibraryProto.Parser, new[]{ "IrVersion", "ProducerVersion", "ProducerTag", "ModelVersion", "ModelAuthor", "ModelLicense", "Name", "Domain", "DocString", "Operator", "Function", "ImportedLibraries" }, null, null, null)
          }));
    }
    #endregion

  }
  #region Enums
  /// <summary>
  /// To be compatible with both proto2 and proto3, we will use a version number
  /// that is not defined by the default value but an explicit enum number.
  /// </summary>
  public enum Version {
    /// <summary>
    /// Just for proto3 compatibility
    /// </summary>
    [pbr::OriginalName("NONE")] None = 0,
    /// <summary>
    /// The version field is always serialized and we will use it to store the
    /// version that the  graph is generated from. This helps us set up version
    /// control. We should use version as
    ///     xx(major) - xx(minor) - xxxx(bugfix)
    /// and we are starting with 00000001.
    /// </summary>
    [pbr::OriginalName("IR_VERSION")] IrVersion = 1,
  }

  #endregion

  #region Messages
  /// <summary>
  /// A named attribute containing either singular float, integer, string
  /// and tensor values, or repeated float, integer, string and tensor values.
  /// An AttributeProto MUST contain the name field, and *only one* of the
  /// following content fields, effectively enforcing a C/C++ union equivalent.
  /// </summary>
  public sealed partial class AttributeProto : pb::IMessage<AttributeProto> {
    private static readonly pb::MessageParser<AttributeProto> _parser = new pb::MessageParser<AttributeProto>(() => new AttributeProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<AttributeProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[0]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AttributeProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AttributeProto(AttributeProto other) : this() {
      name_ = other.name_;
      f_ = other.f_;
      i_ = other.i_;
      s_ = other.s_;
      T = other.t_ != null ? other.T.Clone() : null;
      G = other.g_ != null ? other.G.Clone() : null;
      floats_ = other.floats_.Clone();
      ints_ = other.ints_.Clone();
      strings_ = other.strings_.Clone();
      tensors_ = other.tensors_.Clone();
      graphs_ = other.graphs_.Clone();
      Type = other.type_ != null ? other.Type.Clone() : null;
      types_ = other.types_.Clone();
      Shape = other.shape_ != null ? other.Shape.Clone() : null;
      shapes_ = other.shapes_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public AttributeProto Clone() {
      return new AttributeProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name field MUST be present for this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "f" field.</summary>
    public const int FFieldNumber = 2;
    private float f_;
    /// <summary>
    /// float
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public float F {
      get { return f_; }
      set {
        f_ = value;
      }
    }

    /// <summary>Field number for the "i" field.</summary>
    public const int IFieldNumber = 3;
    private long i_;
    /// <summary>
    /// int
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long I {
      get { return i_; }
      set {
        i_ = value;
      }
    }

    /// <summary>Field number for the "s" field.</summary>
    public const int SFieldNumber = 4;
    private pb::ByteString s_ = pb::ByteString.Empty;
    /// <summary>
    /// UTF-8 string
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString S {
      get { return s_; }
      set {
        s_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "t" field.</summary>
    public const int TFieldNumber = 5;
    private global::LotusIR.TensorProto t_;
    /// <summary>
    /// tensor value
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TensorProto T {
      get { return t_; }
      set {
        t_ = value;
      }
    }

    /// <summary>Field number for the "g" field.</summary>
    public const int GFieldNumber = 6;
    private global::LotusIR.GraphProto g_;
    /// <summary>
    /// graph
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.GraphProto G {
      get { return g_; }
      set {
        g_ = value;
      }
    }

    /// <summary>Field number for the "floats" field.</summary>
    public const int FloatsFieldNumber = 7;
    private static readonly pb::FieldCodec<float> _repeated_floats_codec
        = pb::FieldCodec.ForFloat(58);
    private readonly pbc::RepeatedField<float> floats_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// list of floats
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> Floats {
      get { return floats_; }
    }

    /// <summary>Field number for the "ints" field.</summary>
    public const int IntsFieldNumber = 8;
    private static readonly pb::FieldCodec<long> _repeated_ints_codec
        = pb::FieldCodec.ForInt64(66);
    private readonly pbc::RepeatedField<long> ints_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// list of ints
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Ints {
      get { return ints_; }
    }

    /// <summary>Field number for the "strings" field.</summary>
    public const int StringsFieldNumber = 9;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_strings_codec
        = pb::FieldCodec.ForBytes(74);
    private readonly pbc::RepeatedField<pb::ByteString> strings_ = new pbc::RepeatedField<pb::ByteString>();
    /// <summary>
    /// list of UTF-8 strings
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<pb::ByteString> Strings {
      get { return strings_; }
    }

    /// <summary>Field number for the "tensors" field.</summary>
    public const int TensorsFieldNumber = 10;
    private static readonly pb::FieldCodec<global::LotusIR.TensorProto> _repeated_tensors_codec
        = pb::FieldCodec.ForMessage(82, global::LotusIR.TensorProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.TensorProto> tensors_ = new pbc::RepeatedField<global::LotusIR.TensorProto>();
    /// <summary>
    /// list of tensors
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.TensorProto> Tensors {
      get { return tensors_; }
    }

    /// <summary>Field number for the "graphs" field.</summary>
    public const int GraphsFieldNumber = 11;
    private static readonly pb::FieldCodec<global::LotusIR.GraphProto> _repeated_graphs_codec
        = pb::FieldCodec.ForMessage(90, global::LotusIR.GraphProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.GraphProto> graphs_ = new pbc::RepeatedField<global::LotusIR.GraphProto>();
    /// <summary>
    /// list of graph
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.GraphProto> Graphs {
      get { return graphs_; }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 51;
    private global::LotusIR.TypeProto type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TypeProto Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "types" field.</summary>
    public const int Types_FieldNumber = 52;
    private static readonly pb::FieldCodec<global::LotusIR.TypeProto> _repeated_types_codec
        = pb::FieldCodec.ForMessage(418, global::LotusIR.TypeProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.TypeProto> types_ = new pbc::RepeatedField<global::LotusIR.TypeProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.TypeProto> Types_ {
      get { return types_; }
    }

    /// <summary>Field number for the "shape" field.</summary>
    public const int ShapeFieldNumber = 53;
    private global::LotusIR.TypeProto.Types.TensorShapeProto shape_;
    /// <summary>
    ///ISSUE:13807134,dbox: Do we ever see shape showing up as an attribute value?
    ///            If so, won't it always be accompanied by a TypeProto?
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TypeProto.Types.TensorShapeProto Shape {
      get { return shape_; }
      set {
        shape_ = value;
      }
    }

    /// <summary>Field number for the "shapes" field.</summary>
    public const int ShapesFieldNumber = 54;
    private static readonly pb::FieldCodec<global::LotusIR.TypeProto.Types.TensorShapeProto> _repeated_shapes_codec
        = pb::FieldCodec.ForMessage(434, global::LotusIR.TypeProto.Types.TensorShapeProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.TypeProto.Types.TensorShapeProto> shapes_ = new pbc::RepeatedField<global::LotusIR.TypeProto.Types.TensorShapeProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.TypeProto.Types.TensorShapeProto> Shapes {
      get { return shapes_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as AttributeProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(AttributeProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (F != other.F) return false;
      if (I != other.I) return false;
      if (S != other.S) return false;
      if (!object.Equals(T, other.T)) return false;
      if (!object.Equals(G, other.G)) return false;
      if(!floats_.Equals(other.floats_)) return false;
      if(!ints_.Equals(other.ints_)) return false;
      if(!strings_.Equals(other.strings_)) return false;
      if(!tensors_.Equals(other.tensors_)) return false;
      if(!graphs_.Equals(other.graphs_)) return false;
      if (!object.Equals(Type, other.Type)) return false;
      if(!types_.Equals(other.types_)) return false;
      if (!object.Equals(Shape, other.Shape)) return false;
      if(!shapes_.Equals(other.shapes_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (F != 0F) hash ^= F.GetHashCode();
      if (I != 0L) hash ^= I.GetHashCode();
      if (S.Length != 0) hash ^= S.GetHashCode();
      if (t_ != null) hash ^= T.GetHashCode();
      if (g_ != null) hash ^= G.GetHashCode();
      hash ^= floats_.GetHashCode();
      hash ^= ints_.GetHashCode();
      hash ^= strings_.GetHashCode();
      hash ^= tensors_.GetHashCode();
      hash ^= graphs_.GetHashCode();
      if (type_ != null) hash ^= Type.GetHashCode();
      hash ^= types_.GetHashCode();
      if (shape_ != null) hash ^= Shape.GetHashCode();
      hash ^= shapes_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (F != 0F) {
        output.WriteRawTag(21);
        output.WriteFloat(F);
      }
      if (I != 0L) {
        output.WriteRawTag(24);
        output.WriteInt64(I);
      }
      if (S.Length != 0) {
        output.WriteRawTag(34);
        output.WriteBytes(S);
      }
      if (t_ != null) {
        output.WriteRawTag(42);
        output.WriteMessage(T);
      }
      if (g_ != null) {
        output.WriteRawTag(50);
        output.WriteMessage(G);
      }
      floats_.WriteTo(output, _repeated_floats_codec);
      ints_.WriteTo(output, _repeated_ints_codec);
      strings_.WriteTo(output, _repeated_strings_codec);
      tensors_.WriteTo(output, _repeated_tensors_codec);
      graphs_.WriteTo(output, _repeated_graphs_codec);
      if (type_ != null) {
        output.WriteRawTag(154, 3);
        output.WriteMessage(Type);
      }
      types_.WriteTo(output, _repeated_types_codec);
      if (shape_ != null) {
        output.WriteRawTag(170, 3);
        output.WriteMessage(Shape);
      }
      shapes_.WriteTo(output, _repeated_shapes_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (F != 0F) {
        size += 1 + 4;
      }
      if (I != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(I);
      }
      if (S.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(S);
      }
      if (t_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(T);
      }
      if (g_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(G);
      }
      size += floats_.CalculateSize(_repeated_floats_codec);
      size += ints_.CalculateSize(_repeated_ints_codec);
      size += strings_.CalculateSize(_repeated_strings_codec);
      size += tensors_.CalculateSize(_repeated_tensors_codec);
      size += graphs_.CalculateSize(_repeated_graphs_codec);
      if (type_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Type);
      }
      size += types_.CalculateSize(_repeated_types_codec);
      if (shape_ != null) {
        size += 2 + pb::CodedOutputStream.ComputeMessageSize(Shape);
      }
      size += shapes_.CalculateSize(_repeated_shapes_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(AttributeProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.F != 0F) {
        F = other.F;
      }
      if (other.I != 0L) {
        I = other.I;
      }
      if (other.S.Length != 0) {
        S = other.S;
      }
      if (other.t_ != null) {
        if (t_ == null) {
          t_ = new global::LotusIR.TensorProto();
        }
        T.MergeFrom(other.T);
      }
      if (other.g_ != null) {
        if (g_ == null) {
          g_ = new global::LotusIR.GraphProto();
        }
        G.MergeFrom(other.G);
      }
      floats_.Add(other.floats_);
      ints_.Add(other.ints_);
      strings_.Add(other.strings_);
      tensors_.Add(other.tensors_);
      graphs_.Add(other.graphs_);
      if (other.type_ != null) {
        if (type_ == null) {
          type_ = new global::LotusIR.TypeProto();
        }
        Type.MergeFrom(other.Type);
      }
      types_.Add(other.types_);
      if (other.shape_ != null) {
        if (shape_ == null) {
          shape_ = new global::LotusIR.TypeProto.Types.TensorShapeProto();
        }
        Shape.MergeFrom(other.Shape);
      }
      shapes_.Add(other.shapes_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 21: {
            F = input.ReadFloat();
            break;
          }
          case 24: {
            I = input.ReadInt64();
            break;
          }
          case 34: {
            S = input.ReadBytes();
            break;
          }
          case 42: {
            if (t_ == null) {
              t_ = new global::LotusIR.TensorProto();
            }
            input.ReadMessage(t_);
            break;
          }
          case 50: {
            if (g_ == null) {
              g_ = new global::LotusIR.GraphProto();
            }
            input.ReadMessage(g_);
            break;
          }
          case 58:
          case 61: {
            floats_.AddEntriesFrom(input, _repeated_floats_codec);
            break;
          }
          case 66:
          case 64: {
            ints_.AddEntriesFrom(input, _repeated_ints_codec);
            break;
          }
          case 74: {
            strings_.AddEntriesFrom(input, _repeated_strings_codec);
            break;
          }
          case 82: {
            tensors_.AddEntriesFrom(input, _repeated_tensors_codec);
            break;
          }
          case 90: {
            graphs_.AddEntriesFrom(input, _repeated_graphs_codec);
            break;
          }
          case 410: {
            if (type_ == null) {
              type_ = new global::LotusIR.TypeProto();
            }
            input.ReadMessage(type_);
            break;
          }
          case 418: {
            types_.AddEntriesFrom(input, _repeated_types_codec);
            break;
          }
          case 426: {
            if (shape_ == null) {
              shape_ = new global::LotusIR.TypeProto.Types.TensorShapeProto();
            }
            input.ReadMessage(shape_);
            break;
          }
          case 434: {
            shapes_.AddEntriesFrom(input, _repeated_shapes_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Defines information on value, including the name, the type, and
  /// the shape of the value.
  /// </summary>
  public sealed partial class ValueInfoProto : pb::IMessage<ValueInfoProto> {
    private static readonly pb::MessageParser<ValueInfoProto> _parser = new pb::MessageParser<ValueInfoProto>(() => new ValueInfoProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ValueInfoProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[1]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueInfoProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueInfoProto(ValueInfoProto other) : this() {
      name_ = other.name_;
      Type = other.type_ != null ? other.Type.Clone() : null;
      docString_ = other.docString_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueInfoProto Clone() {
      return new ValueInfoProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// This field MUST be present in this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::LotusIR.TypeProto type_;
    /// <summary>
    /// This field MUST be present in this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TypeProto Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 3;
    private string docString_ = "";
    /// <summary>
    /// An  human-readable documentation for this node in the graph.
    /// This text MAY contain Markdown markup that conforms to http://commonmark.org/. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ValueInfoProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ValueInfoProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Type, other.Type)) return false;
      if (DocString != other.DocString) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (type_ != null) hash ^= Type.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (type_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Type);
      }
      if (DocString.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DocString);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (type_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Type);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ValueInfoProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.type_ != null) {
        if (type_ == null) {
          type_ = new global::LotusIR.TypeProto();
        }
        Type.MergeFrom(other.Type);
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (type_ == null) {
              type_ = new global::LotusIR.TypeProto();
            }
            input.ReadMessage(type_);
            break;
          }
          case 26: {
            DocString = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Defines a node in a computation graph. Each graph node is either an
  /// operator or a function call. A node that is similar to the notion of "layer"
  /// or "operator" in many deep learning frameworks. For example, it can be a
  /// node of type "Conv" that takes in an image, a filter tensor and a bias
  /// tensor, and produces the convolved output.
  ///
  /// NOTE: Control flow is defined by two built-in operators:
  ///
  /// Cond(p, true_input, false_input) takes three inputs, where p is a
  /// boolean scalar tensor, true_input is the list of inputs to the true
  /// branch of cond, and false_input is the list of inputs to the false
  /// branch of cond. The true and false branches are defined as 
  /// functions that takes true_input and false_input as inputs respectively.
  /// The two functions must have the same number of outputs, and each
  /// corresponding output must have the same types, and have compatible
  /// shapes.
  ///
  /// While(vars, consts) takes two inputs, where vars are the initial
  /// values of the loop variables and consts are the values of constants
  /// used inside the loop. The loop condition and loop body are defined
  /// as functions. The functions take both vars and consts as inputs.
  /// The loop condition function returns a boolean scalar tensor. The
  /// loop body function has the form: body(vars, consts) = new_vars,
  /// where new_vars are the new values of the loop variables after one
  /// iteration so must match vars in terms of types and shapes.
  /// </summary>
  public sealed partial class NodeProto : pb::IMessage<NodeProto> {
    private static readonly pb::MessageParser<NodeProto> _parser = new pb::MessageParser<NodeProto>(() => new NodeProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<NodeProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[2]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeProto(NodeProto other) : this() {
      input_ = other.input_.Clone();
      output_ = other.output_.Clone();
      name_ = other.name_;
      opType_ = other.opType_;
      attribute_ = other.attribute_.Clone();
      docString_ = other.docString_;
      inputArgCount_ = other.inputArgCount_.Clone();
      controlInput_ = other.controlInput_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public NodeProto Clone() {
      return new NodeProto(this);
    }

    /// <summary>Field number for the "input" field.</summary>
    public const int InputFieldNumber = 1;
    private static readonly pb::FieldCodec<string> _repeated_input_codec
        = pb::FieldCodec.ForString(10);
    private readonly pbc::RepeatedField<string> input_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// The named inputs of the node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Input {
      get { return input_; }
    }

    /// <summary>Field number for the "output" field.</summary>
    public const int OutputFieldNumber = 2;
    private static readonly pb::FieldCodec<string> _repeated_output_codec
        = pb::FieldCodec.ForString(18);
    private readonly pbc::RepeatedField<string> output_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// The named outputs of the node.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> Output {
      get { return output_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 3;
    private string name_ = "";
    /// <summary>
    /// The name of this node.
    /// This field is  and used to uniquely identify nodes in the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "op_type" field.</summary>
    public const int OpTypeFieldNumber = 4;
    private string opType_ = "";
    /// <summary>
    /// The name of the operator/function called by the node.
    /// This field MUST be present for this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string OpType {
      get { return opType_; }
      set {
        opType_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "attribute" field.</summary>
    public const int AttributeFieldNumber = 5;
    private static readonly pb::FieldCodec<global::LotusIR.AttributeProto> _repeated_attribute_codec
        = pb::FieldCodec.ForMessage(42, global::LotusIR.AttributeProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.AttributeProto> attribute_ = new pbc::RepeatedField<global::LotusIR.AttributeProto>();
    /// <summary>
    /// Additional named attributes.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.AttributeProto> Attribute {
      get { return attribute_; }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 6;
    private string docString_ = "";
    /// <summary>
    /// An  human-readable documentation for this node in the graph.
    /// This text MAY contain Markdown markup that conforms to http://commonmark.org/. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "input_arg_count" field.</summary>
    public const int InputArgCountFieldNumber = 50;
    private static readonly pb::FieldCodec<int> _repeated_inputArgCount_codec
        = pb::FieldCodec.ForInt32(402);
    private readonly pbc::RepeatedField<int> inputArgCount_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// The number of inputs for each argument of the operator/function.
    /// A formal parameter of the op may take a variable number of inputs
    /// that is only known when this node is constructed.
    ///BUG:13806939,dbox: I'm assuming that this field is like input_arg_info in that
    ///          a zero element/missing array implies that one needs to crawl
    ///          the graph to figure out the input counts, yes? Confirm and I'll
    ///          make clear.  Otherwise, we need to require it to be present
    ///          and accurate.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> InputArgCount {
      get { return inputArgCount_; }
    }

    /// <summary>Field number for the "control_input" field.</summary>
    public const int ControlInputFieldNumber = 51;
    private static readonly pb::FieldCodec<string> _repeated_controlInput_codec
        = pb::FieldCodec.ForString(410);
    private readonly pbc::RepeatedField<string> controlInput_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Specify a list of named nodes that must be executed before this node.
    /// Framework may use this to give users the ability to impose additional
    /// execution orders for the operations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ControlInput {
      get { return controlInput_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as NodeProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(NodeProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!input_.Equals(other.input_)) return false;
      if(!output_.Equals(other.output_)) return false;
      if (Name != other.Name) return false;
      if (OpType != other.OpType) return false;
      if(!attribute_.Equals(other.attribute_)) return false;
      if (DocString != other.DocString) return false;
      if(!inputArgCount_.Equals(other.inputArgCount_)) return false;
      if(!controlInput_.Equals(other.controlInput_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= input_.GetHashCode();
      hash ^= output_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (OpType.Length != 0) hash ^= OpType.GetHashCode();
      hash ^= attribute_.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      hash ^= inputArgCount_.GetHashCode();
      hash ^= controlInput_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      input_.WriteTo(output, _repeated_input_codec);
      output_.WriteTo(output, _repeated_output_codec);
      if (Name.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(Name);
      }
      if (OpType.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(OpType);
      }
      attribute_.WriteTo(output, _repeated_attribute_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(DocString);
      }
      inputArgCount_.WriteTo(output, _repeated_inputArgCount_codec);
      controlInput_.WriteTo(output, _repeated_controlInput_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += input_.CalculateSize(_repeated_input_codec);
      size += output_.CalculateSize(_repeated_output_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (OpType.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(OpType);
      }
      size += attribute_.CalculateSize(_repeated_attribute_codec);
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      size += inputArgCount_.CalculateSize(_repeated_inputArgCount_codec);
      size += controlInput_.CalculateSize(_repeated_controlInput_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(NodeProto other) {
      if (other == null) {
        return;
      }
      input_.Add(other.input_);
      output_.Add(other.output_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.OpType.Length != 0) {
        OpType = other.OpType;
      }
      attribute_.Add(other.attribute_);
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      inputArgCount_.Add(other.inputArgCount_);
      controlInput_.Add(other.controlInput_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            input_.AddEntriesFrom(input, _repeated_input_codec);
            break;
          }
          case 18: {
            output_.AddEntriesFrom(input, _repeated_output_codec);
            break;
          }
          case 26: {
            Name = input.ReadString();
            break;
          }
          case 34: {
            OpType = input.ReadString();
            break;
          }
          case 42: {
            attribute_.AddEntriesFrom(input, _repeated_attribute_codec);
            break;
          }
          case 50: {
            DocString = input.ReadString();
            break;
          }
          case 402:
          case 400: {
            inputArgCount_.AddEntriesFrom(input, _repeated_inputArgCount_codec);
            break;
          }
          case 410: {
            controlInput_.AddEntriesFrom(input, _repeated_controlInput_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// ModelProto is a top-level file/container format for bundling a ML model.
  /// The semantics of the model are described by the GraphProto that represents
  /// a parameterized computation graph against a set of named operators that are
  /// defined independently from the graph.
  /// </summary>
  public sealed partial class ModelProto : pb::IMessage<ModelProto> {
    private static readonly pb::MessageParser<ModelProto> _parser = new pb::MessageParser<ModelProto>(() => new ModelProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ModelProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[3]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelProto(ModelProto other) : this() {
      irVersion_ = other.irVersion_;
      producerName_ = other.producerName_;
      producerVersion_ = other.producerVersion_;
      domain_ = other.domain_;
      modelVersion_ = other.modelVersion_;
      docString_ = other.docString_;
      Graph = other.graph_ != null ? other.Graph.Clone() : null;
      modelAuthor_ = other.modelAuthor_;
      modelLicense_ = other.modelLicense_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ModelProto Clone() {
      return new ModelProto(this);
    }

    /// <summary>Field number for the "ir_version" field.</summary>
    public const int IrVersionFieldNumber = 1;
    private long irVersion_;
    /// <summary>
    /// The version of the IR this model targets. See Version enum above.
    /// This field MUST be present.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IrVersion {
      get { return irVersion_; }
      set {
        irVersion_ = value;
      }
    }

    /// <summary>Field number for the "producer_name" field.</summary>
    public const int ProducerNameFieldNumber = 2;
    private string producerName_ = "";
    /// <summary>
    /// The name of the framework or tool used to generate this model.
    /// This field SHOULD be present to indicate which implementation/tool/framework
    /// emitted the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProducerName {
      get { return producerName_; }
      set {
        producerName_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "producer_version" field.</summary>
    public const int ProducerVersionFieldNumber = 3;
    private string producerVersion_ = "";
    /// <summary>
    /// The version of the framework or tool used to generate this model.
    /// This field SHOULD be present to indicate which implementation/tool/framework
    /// emitted the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProducerVersion {
      get { return producerVersion_; }
      set {
        producerVersion_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "domain" field.</summary>
    public const int DomainFieldNumber = 4;
    private string domain_ = "";
    /// <summary>
    /// Domain name of the model.
    /// We use reverse domain names as name space indicators. For example:
    /// `com.facebook.fair` or `com.microsoft.cognitiveservices`
    ///
    /// Together with `model_version` and GraphProto.name, this forms the unique identity of
    /// the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Domain {
      get { return domain_; }
      set {
        domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_version" field.</summary>
    public const int ModelVersionFieldNumber = 5;
    private long modelVersion_;
    /// <summary>
    /// The version of the graph encoded. See Version enum below.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ModelVersion {
      get { return modelVersion_; }
      set {
        modelVersion_ = value;
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 6;
    private string docString_ = "";
    /// <summary>
    /// A human-readable documentation for this model. Markdown is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "graph" field.</summary>
    public const int GraphFieldNumber = 7;
    private global::LotusIR.GraphProto graph_;
    /// <summary>
    /// The parameterized graph that is evaluated to execute the model.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.GraphProto Graph {
      get { return graph_; }
      set {
        graph_ = value;
      }
    }

    /// <summary>Field number for the "model_author" field.</summary>
    public const int ModelAuthorFieldNumber = 50;
    private string modelAuthor_ = "";
    /// <summary>
    /// The  name of the author who created the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelAuthor {
      get { return modelAuthor_; }
      set {
        modelAuthor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_license" field.</summary>
    public const int ModelLicenseFieldNumber = 51;
    private string modelLicense_ = "";
    /// <summary>
    ///  licensing information concerning use or origination of the graph.
    /// This text MAY contain Markdown markup that conforms to http://commonmark.org/. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelLicense {
      get { return modelLicense_; }
      set {
        modelLicense_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ModelProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ModelProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IrVersion != other.IrVersion) return false;
      if (ProducerName != other.ProducerName) return false;
      if (ProducerVersion != other.ProducerVersion) return false;
      if (Domain != other.Domain) return false;
      if (ModelVersion != other.ModelVersion) return false;
      if (DocString != other.DocString) return false;
      if (!object.Equals(Graph, other.Graph)) return false;
      if (ModelAuthor != other.ModelAuthor) return false;
      if (ModelLicense != other.ModelLicense) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (IrVersion != 0L) hash ^= IrVersion.GetHashCode();
      if (ProducerName.Length != 0) hash ^= ProducerName.GetHashCode();
      if (ProducerVersion.Length != 0) hash ^= ProducerVersion.GetHashCode();
      if (Domain.Length != 0) hash ^= Domain.GetHashCode();
      if (ModelVersion != 0L) hash ^= ModelVersion.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      if (graph_ != null) hash ^= Graph.GetHashCode();
      if (ModelAuthor.Length != 0) hash ^= ModelAuthor.GetHashCode();
      if (ModelLicense.Length != 0) hash ^= ModelLicense.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (IrVersion != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(IrVersion);
      }
      if (ProducerName.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(ProducerName);
      }
      if (ProducerVersion.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ProducerVersion);
      }
      if (Domain.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(Domain);
      }
      if (ModelVersion != 0L) {
        output.WriteRawTag(40);
        output.WriteInt64(ModelVersion);
      }
      if (DocString.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(DocString);
      }
      if (graph_ != null) {
        output.WriteRawTag(58);
        output.WriteMessage(Graph);
      }
      if (ModelAuthor.Length != 0) {
        output.WriteRawTag(146, 3);
        output.WriteString(ModelAuthor);
      }
      if (ModelLicense.Length != 0) {
        output.WriteRawTag(154, 3);
        output.WriteString(ModelLicense);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (IrVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IrVersion);
      }
      if (ProducerName.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProducerName);
      }
      if (ProducerVersion.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProducerVersion);
      }
      if (Domain.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
      }
      if (ModelVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ModelVersion);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      if (graph_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Graph);
      }
      if (ModelAuthor.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ModelAuthor);
      }
      if (ModelLicense.Length != 0) {
        size += 2 + pb::CodedOutputStream.ComputeStringSize(ModelLicense);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ModelProto other) {
      if (other == null) {
        return;
      }
      if (other.IrVersion != 0L) {
        IrVersion = other.IrVersion;
      }
      if (other.ProducerName.Length != 0) {
        ProducerName = other.ProducerName;
      }
      if (other.ProducerVersion.Length != 0) {
        ProducerVersion = other.ProducerVersion;
      }
      if (other.Domain.Length != 0) {
        Domain = other.Domain;
      }
      if (other.ModelVersion != 0L) {
        ModelVersion = other.ModelVersion;
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      if (other.graph_ != null) {
        if (graph_ == null) {
          graph_ = new global::LotusIR.GraphProto();
        }
        Graph.MergeFrom(other.Graph);
      }
      if (other.ModelAuthor.Length != 0) {
        ModelAuthor = other.ModelAuthor;
      }
      if (other.ModelLicense.Length != 0) {
        ModelLicense = other.ModelLicense;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            IrVersion = input.ReadInt64();
            break;
          }
          case 18: {
            ProducerName = input.ReadString();
            break;
          }
          case 26: {
            ProducerVersion = input.ReadString();
            break;
          }
          case 34: {
            Domain = input.ReadString();
            break;
          }
          case 40: {
            ModelVersion = input.ReadInt64();
            break;
          }
          case 50: {
            DocString = input.ReadString();
            break;
          }
          case 58: {
            if (graph_ == null) {
              graph_ = new global::LotusIR.GraphProto();
            }
            input.ReadMessage(graph_);
            break;
          }
          case 402: {
            ModelAuthor = input.ReadString();
            break;
          }
          case 410: {
            ModelLicense = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// GraphProto defines a parameterized series of nodes to form a directed acyclic graph.
  /// This is the equivalent of the "network" and "graph" in many deep learning
  /// frameworks.
  /// All the input/output tensors are explicitly named so a framework can
  /// run any subgraph of the graph by feeding and fetching the named tensors.
  /// </summary>
  public sealed partial class GraphProto : pb::IMessage<GraphProto> {
    private static readonly pb::MessageParser<GraphProto> _parser = new pb::MessageParser<GraphProto>(() => new GraphProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<GraphProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[4]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraphProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraphProto(GraphProto other) : this() {
      node_ = other.node_.Clone();
      name_ = other.name_;
      initializer_ = other.initializer_.Clone();
      docString_ = other.docString_;
      input_ = other.input_.Clone();
      output_ = other.output_.Clone();
      valueInfo_ = other.valueInfo_.Clone();
      function_ = other.function_.Clone();
      operator_ = other.operator_.Clone();
      importedLibraries_ = other.importedLibraries_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public GraphProto Clone() {
      return new GraphProto(this);
    }

    /// <summary>Field number for the "node" field.</summary>
    public const int NodeFieldNumber = 1;
    private static readonly pb::FieldCodec<global::LotusIR.NodeProto> _repeated_node_codec
        = pb::FieldCodec.ForMessage(10, global::LotusIR.NodeProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.NodeProto> node_ = new pbc::RepeatedField<global::LotusIR.NodeProto>();
    /// <summary>
    /// The nodes in the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.NodeProto> Node {
      get { return node_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 2;
    private string name_ = "";
    /// <summary>
    /// The name of the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "initializer" field.</summary>
    public const int InitializerFieldNumber = 5;
    private static readonly pb::FieldCodec<global::LotusIR.TensorProto> _repeated_initializer_codec
        = pb::FieldCodec.ForMessage(42, global::LotusIR.TensorProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.TensorProto> initializer_ = new pbc::RepeatedField<global::LotusIR.TensorProto>();
    /// <summary>
    /// A list of named tensor values (constants), used to specify default
    /// values for some of the inputs of the graph.
    /// Each TensorProto entry must have a distinct name (within the list) that
    /// also appears in the input list.
    /// In an evaluation, the default value specified here is used if and only if
    /// user specifies no value for the corresponding input parameter.
    /// May be used to pass serialized parameters for networks.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.TensorProto> Initializer {
      get { return initializer_; }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 10;
    private string docString_ = "";
    /// <summary>
    /// A human-readable documentation for this graph. Markdown is allowed.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "input" field.</summary>
    public const int InputFieldNumber = 11;
    private static readonly pb::FieldCodec<global::LotusIR.ValueInfoProto> _repeated_input_codec
        = pb::FieldCodec.ForMessage(90, global::LotusIR.ValueInfoProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.ValueInfoProto> input_ = new pbc::RepeatedField<global::LotusIR.ValueInfoProto>();
    /// <summary>
    /// The inputs and outputs of the graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.ValueInfoProto> Input {
      get { return input_; }
    }

    /// <summary>Field number for the "output" field.</summary>
    public const int OutputFieldNumber = 12;
    private static readonly pb::FieldCodec<global::LotusIR.ValueInfoProto> _repeated_output_codec
        = pb::FieldCodec.ForMessage(98, global::LotusIR.ValueInfoProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.ValueInfoProto> output_ = new pbc::RepeatedField<global::LotusIR.ValueInfoProto>();
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.ValueInfoProto> Output {
      get { return output_; }
    }

    /// <summary>Field number for the "value_info" field.</summary>
    public const int ValueInfoFieldNumber = 13;
    private static readonly pb::FieldCodec<global::LotusIR.ValueInfoProto> _repeated_valueInfo_codec
        = pb::FieldCodec.ForMessage(106, global::LotusIR.ValueInfoProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.ValueInfoProto> valueInfo_ = new pbc::RepeatedField<global::LotusIR.ValueInfoProto>();
    /// <summary>
    /// Information for the values in the graph. The ValueInfoProto.name's
    /// must be distinct. It is  for a value to appear in value_info list.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.ValueInfoProto> ValueInfo {
      get { return valueInfo_; }
    }

    /// <summary>Field number for the "function" field.</summary>
    public const int FunctionFieldNumber = 50;
    private static readonly pb::FieldCodec<global::LotusIR.FunctionDefProto> _repeated_function_codec
        = pb::FieldCodec.ForMessage(402, global::LotusIR.FunctionDefProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.FunctionDefProto> function_ = new pbc::RepeatedField<global::LotusIR.FunctionDefProto>();
    /// <summary>
    /// The function definitions of the graph. They can only only be used
    /// (i.e., called) in this graph.
    /// Each FunctionDefProto in function MUST have a unique name. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.FunctionDefProto> Function {
      get { return function_; }
    }

    /// <summary>Field number for the "operator" field.</summary>
    public const int OperatorFieldNumber = 51;
    private static readonly pb::FieldCodec<global::LotusIR.OperatorDeclProto> _repeated_operator_codec
        = pb::FieldCodec.ForMessage(410, global::LotusIR.OperatorDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.OperatorDeclProto> operator_ = new pbc::RepeatedField<global::LotusIR.OperatorDeclProto>();
    /// <summary>
    /// The externally defined operators declared by this graph. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.OperatorDeclProto> Operator {
      get { return operator_; }
    }

    /// <summary>Field number for the "imported_libraries" field.</summary>
    public const int ImportedLibrariesFieldNumber = 52;
    private static readonly pb::FieldCodec<string> _repeated_importedLibraries_codec
        = pb::FieldCodec.ForString(418);
    private readonly pbc::RepeatedField<string> importedLibraries_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Imported libraries are referenced as a collection of strings in the form of absolute
    /// URIs or relative paths. Where such relative paths are rooted is defined by tools and
    /// runtime implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ImportedLibraries {
      get { return importedLibraries_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as GraphProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(GraphProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!node_.Equals(other.node_)) return false;
      if (Name != other.Name) return false;
      if(!initializer_.Equals(other.initializer_)) return false;
      if (DocString != other.DocString) return false;
      if(!input_.Equals(other.input_)) return false;
      if(!output_.Equals(other.output_)) return false;
      if(!valueInfo_.Equals(other.valueInfo_)) return false;
      if(!function_.Equals(other.function_)) return false;
      if(!operator_.Equals(other.operator_)) return false;
      if(!importedLibraries_.Equals(other.importedLibraries_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= node_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= initializer_.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      hash ^= input_.GetHashCode();
      hash ^= output_.GetHashCode();
      hash ^= valueInfo_.GetHashCode();
      hash ^= function_.GetHashCode();
      hash ^= operator_.GetHashCode();
      hash ^= importedLibraries_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      node_.WriteTo(output, _repeated_node_codec);
      if (Name.Length != 0) {
        output.WriteRawTag(18);
        output.WriteString(Name);
      }
      initializer_.WriteTo(output, _repeated_initializer_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(82);
        output.WriteString(DocString);
      }
      input_.WriteTo(output, _repeated_input_codec);
      output_.WriteTo(output, _repeated_output_codec);
      valueInfo_.WriteTo(output, _repeated_valueInfo_codec);
      function_.WriteTo(output, _repeated_function_codec);
      operator_.WriteTo(output, _repeated_operator_codec);
      importedLibraries_.WriteTo(output, _repeated_importedLibraries_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += node_.CalculateSize(_repeated_node_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += initializer_.CalculateSize(_repeated_initializer_codec);
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      size += input_.CalculateSize(_repeated_input_codec);
      size += output_.CalculateSize(_repeated_output_codec);
      size += valueInfo_.CalculateSize(_repeated_valueInfo_codec);
      size += function_.CalculateSize(_repeated_function_codec);
      size += operator_.CalculateSize(_repeated_operator_codec);
      size += importedLibraries_.CalculateSize(_repeated_importedLibraries_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(GraphProto other) {
      if (other == null) {
        return;
      }
      node_.Add(other.node_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      initializer_.Add(other.initializer_);
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      input_.Add(other.input_);
      output_.Add(other.output_);
      valueInfo_.Add(other.valueInfo_);
      function_.Add(other.function_);
      operator_.Add(other.operator_);
      importedLibraries_.Add(other.importedLibraries_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            node_.AddEntriesFrom(input, _repeated_node_codec);
            break;
          }
          case 18: {
            Name = input.ReadString();
            break;
          }
          case 42: {
            initializer_.AddEntriesFrom(input, _repeated_initializer_codec);
            break;
          }
          case 82: {
            DocString = input.ReadString();
            break;
          }
          case 90: {
            input_.AddEntriesFrom(input, _repeated_input_codec);
            break;
          }
          case 98: {
            output_.AddEntriesFrom(input, _repeated_output_codec);
            break;
          }
          case 106: {
            valueInfo_.AddEntriesFrom(input, _repeated_valueInfo_codec);
            break;
          }
          case 402: {
            function_.AddEntriesFrom(input, _repeated_function_codec);
            break;
          }
          case 410: {
            operator_.AddEntriesFrom(input, _repeated_operator_codec);
            break;
          }
          case 418: {
            importedLibraries_.AddEntriesFrom(input, _repeated_importedLibraries_codec);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A message defined to store a tensor in its serialized format.
  /// </summary>
  public sealed partial class TensorProto : pb::IMessage<TensorProto> {
    private static readonly pb::MessageParser<TensorProto> _parser = new pb::MessageParser<TensorProto>(() => new TensorProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TensorProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[5]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorProto(TensorProto other) : this() {
      dims_ = other.dims_.Clone();
      dataType_ = other.dataType_;
      Segment = other.segment_ != null ? other.Segment.Clone() : null;
      floatData_ = other.floatData_.Clone();
      int32Data_ = other.int32Data_.Clone();
      stringData_ = other.stringData_.Clone();
      int64Data_ = other.int64Data_.Clone();
      name_ = other.name_;
      rawData_ = other.rawData_;
      doubleData_ = other.doubleData_.Clone();
      uint64Data_ = other.uint64Data_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TensorProto Clone() {
      return new TensorProto(this);
    }

    /// <summary>Field number for the "dims" field.</summary>
    public const int DimsFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_dims_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The shape of the tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Dims {
      get { return dims_; }
    }

    /// <summary>Field number for the "data_type" field.</summary>
    public const int DataTypeFieldNumber = 2;
    private global::LotusIR.TensorProto.Types.DataType dataType_ = 0;
    /// <summary>
    /// The data type of the tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TensorProto.Types.DataType DataType {
      get { return dataType_; }
      set {
        dataType_ = value;
      }
    }

    /// <summary>Field number for the "segment" field.</summary>
    public const int SegmentFieldNumber = 3;
    private global::LotusIR.TensorProto.Types.Segment segment_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TensorProto.Types.Segment Segment {
      get { return segment_; }
      set {
        segment_ = value;
      }
    }

    /// <summary>Field number for the "float_data" field.</summary>
    public const int FloatDataFieldNumber = 4;
    private static readonly pb::FieldCodec<float> _repeated_floatData_codec
        = pb::FieldCodec.ForFloat(34);
    private readonly pbc::RepeatedField<float> floatData_ = new pbc::RepeatedField<float>();
    /// <summary>
    /// For float and complex64 values
    /// Complex64 tensors are encoded as a single array of floats,
    /// with the real components appearing in odd numbered positions,
    /// and the corresponding imaginary component apparing in the
    /// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
    /// is encoded as [1.0, 2.0 ,3.0 ,4.0]
    /// When this field is present, the data_type field MUST be FLOAT or COMPLEX64.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<float> FloatData {
      get { return floatData_; }
    }

    /// <summary>Field number for the "int32_data" field.</summary>
    public const int Int32DataFieldNumber = 5;
    private static readonly pb::FieldCodec<int> _repeated_int32Data_codec
        = pb::FieldCodec.ForInt32(42);
    private readonly pbc::RepeatedField<int> int32Data_ = new pbc::RepeatedField<int>();
    /// <summary>
    /// For int32, uint8, int8, uint16, int16, bool, and float16 values
    /// float16 values must be bit-wise converted to an uint16_t prior
    /// to writing to the buffer.
    /// When this field is present, the data_type field MUST be
    /// INT32, INT16, INT8, UINT16, INT8, BOOL, or FLOAT32
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<int> Int32Data {
      get { return int32Data_; }
    }

    /// <summary>Field number for the "string_data" field.</summary>
    public const int StringDataFieldNumber = 6;
    private static readonly pb::FieldCodec<pb::ByteString> _repeated_stringData_codec
        = pb::FieldCodec.ForBytes(50);
    private readonly pbc::RepeatedField<pb::ByteString> stringData_ = new pbc::RepeatedField<pb::ByteString>();
    /// <summary>
    /// For strings.
    /// Each element of string_data is a UTF-8 encoded Unicode
    /// string. No trailing null, no leading BOM. The protobuf "string"
    /// scalar type is not used to match ML community conventions.
    /// When this field is present, the data_type field MUST be STRING
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<pb::ByteString> StringData {
      get { return stringData_; }
    }

    /// <summary>Field number for the "int64_data" field.</summary>
    public const int Int64DataFieldNumber = 7;
    private static readonly pb::FieldCodec<long> _repeated_int64Data_codec
        = pb::FieldCodec.ForInt64(58);
    private readonly pbc::RepeatedField<long> int64Data_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// For int64.
    /// When this field is present, the data_type field MUST be INT64
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Int64Data {
      get { return int64Data_; }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 8;
    private string name_ = "";
    /// <summary>
    /// ly, a name for the tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "raw_data" field.</summary>
    public const int RawDataFieldNumber = 9;
    private pb::ByteString rawData_ = pb::ByteString.Empty;
    /// <summary>
    /// Serializations can either use one of the fields above, or use this
    /// raw bytes field. The only exception is the string case, where one is
    ///  to store the content in the repeated bytes string_data field.
    ///
    /// When this raw_data field is used to store tensor value, elements MUST
    /// be stored in as fixed-width, little-endian order.
    /// Floating-point data types MUST be stored in IEEE 754 format.
    /// Complex64 elements must be written as two consecutive FLOAT values, real component first.
    /// Complex128 elements must be written as two consecutive DOUBLE values, real component first.
    /// Boolean type MUST be written one byte per tensor element (00000001 for true, 00000000 for false).
    ///
    /// Note: the advantage of specific field rather than the raw_data field is
    /// that in some cases (e.g. int data), protobuf does a better packing via
    /// variable length storage, and may lead to smaller binary footprint.
    /// When this field is present, the data_type field MUST NOT be STRING or UNDEFINED
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pb::ByteString RawData {
      get { return rawData_; }
      set {
        rawData_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "double_data" field.</summary>
    public const int DoubleDataFieldNumber = 10;
    private static readonly pb::FieldCodec<double> _repeated_doubleData_codec
        = pb::FieldCodec.ForDouble(82);
    private readonly pbc::RepeatedField<double> doubleData_ = new pbc::RepeatedField<double>();
    /// <summary>
    /// For double
    /// Complex64 tensors are encoded as a single array of doubles,
    /// with the real components appearing in odd numbered positions,
    /// and the corresponding imaginary component apparing in the
    /// subsequent even numbered position. (e.g., [1.0 + 2.0i, 3.0 + 4.0i]
    /// is encoded as [1.0, 2.0 ,3.0 ,4.0]
    /// When this field is present, the data_type field MUST be DOUBLE or COMPLEX128
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<double> DoubleData {
      get { return doubleData_; }
    }

    /// <summary>Field number for the "uint64_data" field.</summary>
    public const int Uint64DataFieldNumber = 11;
    private static readonly pb::FieldCodec<ulong> _repeated_uint64Data_codec
        = pb::FieldCodec.ForUInt64(90);
    private readonly pbc::RepeatedField<ulong> uint64Data_ = new pbc::RepeatedField<ulong>();
    /// <summary>
    /// For uint64 and uint32 values
    /// When this field is present, the data_type field MUST be
    /// UINT32 or UINT64
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<ulong> Uint64Data {
      get { return uint64Data_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TensorProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TensorProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dims_.Equals(other.dims_)) return false;
      if (DataType != other.DataType) return false;
      if (!object.Equals(Segment, other.Segment)) return false;
      if(!floatData_.Equals(other.floatData_)) return false;
      if(!int32Data_.Equals(other.int32Data_)) return false;
      if(!stringData_.Equals(other.stringData_)) return false;
      if(!int64Data_.Equals(other.int64Data_)) return false;
      if (Name != other.Name) return false;
      if (RawData != other.RawData) return false;
      if(!doubleData_.Equals(other.doubleData_)) return false;
      if(!uint64Data_.Equals(other.uint64Data_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dims_.GetHashCode();
      if (DataType != 0) hash ^= DataType.GetHashCode();
      if (segment_ != null) hash ^= Segment.GetHashCode();
      hash ^= floatData_.GetHashCode();
      hash ^= int32Data_.GetHashCode();
      hash ^= stringData_.GetHashCode();
      hash ^= int64Data_.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (RawData.Length != 0) hash ^= RawData.GetHashCode();
      hash ^= doubleData_.GetHashCode();
      hash ^= uint64Data_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      dims_.WriteTo(output, _repeated_dims_codec);
      if (DataType != 0) {
        output.WriteRawTag(16);
        output.WriteEnum((int) DataType);
      }
      if (segment_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Segment);
      }
      floatData_.WriteTo(output, _repeated_floatData_codec);
      int32Data_.WriteTo(output, _repeated_int32Data_codec);
      stringData_.WriteTo(output, _repeated_stringData_codec);
      int64Data_.WriteTo(output, _repeated_int64Data_codec);
      if (Name.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Name);
      }
      if (RawData.Length != 0) {
        output.WriteRawTag(74);
        output.WriteBytes(RawData);
      }
      doubleData_.WriteTo(output, _repeated_doubleData_codec);
      uint64Data_.WriteTo(output, _repeated_uint64Data_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += dims_.CalculateSize(_repeated_dims_codec);
      if (DataType != 0) {
        size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) DataType);
      }
      if (segment_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Segment);
      }
      size += floatData_.CalculateSize(_repeated_floatData_codec);
      size += int32Data_.CalculateSize(_repeated_int32Data_codec);
      size += stringData_.CalculateSize(_repeated_stringData_codec);
      size += int64Data_.CalculateSize(_repeated_int64Data_codec);
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (RawData.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeBytesSize(RawData);
      }
      size += doubleData_.CalculateSize(_repeated_doubleData_codec);
      size += uint64Data_.CalculateSize(_repeated_uint64Data_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TensorProto other) {
      if (other == null) {
        return;
      }
      dims_.Add(other.dims_);
      if (other.DataType != 0) {
        DataType = other.DataType;
      }
      if (other.segment_ != null) {
        if (segment_ == null) {
          segment_ = new global::LotusIR.TensorProto.Types.Segment();
        }
        Segment.MergeFrom(other.Segment);
      }
      floatData_.Add(other.floatData_);
      int32Data_.Add(other.int32Data_);
      stringData_.Add(other.stringData_);
      int64Data_.Add(other.int64Data_);
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.RawData.Length != 0) {
        RawData = other.RawData;
      }
      doubleData_.Add(other.doubleData_);
      uint64Data_.Add(other.uint64Data_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            dims_.AddEntriesFrom(input, _repeated_dims_codec);
            break;
          }
          case 16: {
            dataType_ = (global::LotusIR.TensorProto.Types.DataType) input.ReadEnum();
            break;
          }
          case 26: {
            if (segment_ == null) {
              segment_ = new global::LotusIR.TensorProto.Types.Segment();
            }
            input.ReadMessage(segment_);
            break;
          }
          case 34:
          case 37: {
            floatData_.AddEntriesFrom(input, _repeated_floatData_codec);
            break;
          }
          case 42:
          case 40: {
            int32Data_.AddEntriesFrom(input, _repeated_int32Data_codec);
            break;
          }
          case 50: {
            stringData_.AddEntriesFrom(input, _repeated_stringData_codec);
            break;
          }
          case 58:
          case 56: {
            int64Data_.AddEntriesFrom(input, _repeated_int64Data_codec);
            break;
          }
          case 66: {
            Name = input.ReadString();
            break;
          }
          case 74: {
            RawData = input.ReadBytes();
            break;
          }
          case 82:
          case 81: {
            doubleData_.AddEntriesFrom(input, _repeated_doubleData_codec);
            break;
          }
          case 90:
          case 88: {
            uint64Data_.AddEntriesFrom(input, _repeated_uint64Data_codec);
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TensorProto message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      public enum DataType {
        [pbr::OriginalName("UNDEFINED")] Undefined = 0,
        /// <summary>
        /// Basic types.
        /// </summary>
        [pbr::OriginalName("FLOAT")] Float = 1,
        /// <summary>
        /// uint8_t
        /// </summary>
        [pbr::OriginalName("UINT8")] Uint8 = 2,
        /// <summary>
        /// int8_t
        /// </summary>
        [pbr::OriginalName("INT8")] Int8 = 3,
        /// <summary>
        /// uint16_t
        /// </summary>
        [pbr::OriginalName("UINT16")] Uint16 = 4,
        /// <summary>
        /// int16_t
        /// </summary>
        [pbr::OriginalName("INT16")] Int16 = 5,
        /// <summary>
        /// int32_t
        /// </summary>
        [pbr::OriginalName("INT32")] Int32 = 6,
        /// <summary>
        /// int64_t
        /// </summary>
        [pbr::OriginalName("INT64")] Int64 = 7,
        /// <summary>
        /// string
        /// </summary>
        [pbr::OriginalName("STRING")] String = 8,
        /// <summary>
        /// bool
        /// </summary>
        [pbr::OriginalName("BOOL")] Bool = 9,
        /// <summary>
        /// Advanced types
        /// </summary>
        [pbr::OriginalName("FLOAT16")] Float16 = 10,
        [pbr::OriginalName("DOUBLE")] Double = 11,
        [pbr::OriginalName("UINT32")] Uint32 = 12,
        [pbr::OriginalName("UINT64")] Uint64 = 13,
        /// <summary>
        /// complex with float32 real and imaginary components
        /// </summary>
        [pbr::OriginalName("COMPLEX64")] Complex64 = 14,
        /// <summary>
        /// complex with float64 real and imaginary components
        /// </summary>
        [pbr::OriginalName("COMPLEX128")] Complex128 = 15,
      }

      /// <summary>
      /// For very large tensors, we may want to store them in chunks, in which
      /// case the following fields will specify the segment that is stored in
      /// the current TensorProto.
      /// </summary>
      public sealed partial class Segment : pb::IMessage<Segment> {
        private static readonly pb::MessageParser<Segment> _parser = new pb::MessageParser<Segment>(() => new Segment());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<Segment> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.TensorProto.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Segment() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Segment(Segment other) : this() {
          begin_ = other.begin_;
          end_ = other.end_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public Segment Clone() {
          return new Segment(this);
        }

        /// <summary>Field number for the "begin" field.</summary>
        public const int BeginFieldNumber = 1;
        private long begin_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long Begin {
          get { return begin_; }
          set {
            begin_ = value;
          }
        }

        /// <summary>Field number for the "end" field.</summary>
        public const int EndFieldNumber = 2;
        private long end_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long End {
          get { return end_; }
          set {
            end_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as Segment);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(Segment other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Begin != other.Begin) return false;
          if (End != other.End) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Begin != 0L) hash ^= Begin.GetHashCode();
          if (End != 0L) hash ^= End.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Begin != 0L) {
            output.WriteRawTag(8);
            output.WriteInt64(Begin);
          }
          if (End != 0L) {
            output.WriteRawTag(16);
            output.WriteInt64(End);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Begin != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(Begin);
          }
          if (End != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(End);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(Segment other) {
          if (other == null) {
            return;
          }
          if (other.Begin != 0L) {
            Begin = other.Begin;
          }
          if (other.End != 0L) {
            End = other.End;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Begin = input.ReadInt64();
                break;
              }
              case 16: {
                End = input.ReadInt64();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  /// <summary>
  /// A sparse tensor must be stored as three dense tensors:
  ///  1. dims: The shape of the original dense tensor.
  ///  2. indices: A 2-D tensor specifying the indices of the nonzero elements.
  ///  3. values: A 1-D tensor containing the values of the nonzero elements.
  /// </summary>
  public sealed partial class SparseTensorProto : pb::IMessage<SparseTensorProto> {
    private static readonly pb::MessageParser<SparseTensorProto> _parser = new pb::MessageParser<SparseTensorProto>(() => new SparseTensorProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SparseTensorProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[6]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SparseTensorProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SparseTensorProto(SparseTensorProto other) : this() {
      dims_ = other.dims_.Clone();
      Indices = other.indices_ != null ? other.Indices.Clone() : null;
      Values = other.values_ != null ? other.Values.Clone() : null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SparseTensorProto Clone() {
      return new SparseTensorProto(this);
    }

    /// <summary>Field number for the "dims" field.</summary>
    public const int DimsFieldNumber = 1;
    private static readonly pb::FieldCodec<long> _repeated_dims_codec
        = pb::FieldCodec.ForInt64(10);
    private readonly pbc::RepeatedField<long> dims_ = new pbc::RepeatedField<long>();
    /// <summary>
    /// The dimensions in the tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<long> Dims {
      get { return dims_; }
    }

    /// <summary>Field number for the "indices" field.</summary>
    public const int IndicesFieldNumber = 2;
    private global::LotusIR.TensorProto indices_;
    /// <summary>
    /// This field MUST be present this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TensorProto Indices {
      get { return indices_; }
      set {
        indices_ = value;
      }
    }

    /// <summary>Field number for the "values" field.</summary>
    public const int ValuesFieldNumber = 3;
    private global::LotusIR.TensorProto values_;
    /// <summary>
    /// This field MUST be present this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TensorProto Values {
      get { return values_; }
      set {
        values_ = value;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SparseTensorProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SparseTensorProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!dims_.Equals(other.dims_)) return false;
      if (!object.Equals(Indices, other.Indices)) return false;
      if (!object.Equals(Values, other.Values)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= dims_.GetHashCode();
      if (indices_ != null) hash ^= Indices.GetHashCode();
      if (values_ != null) hash ^= Values.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      dims_.WriteTo(output, _repeated_dims_codec);
      if (indices_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Indices);
      }
      if (values_ != null) {
        output.WriteRawTag(26);
        output.WriteMessage(Values);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += dims_.CalculateSize(_repeated_dims_codec);
      if (indices_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Indices);
      }
      if (values_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Values);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SparseTensorProto other) {
      if (other == null) {
        return;
      }
      dims_.Add(other.dims_);
      if (other.indices_ != null) {
        if (indices_ == null) {
          indices_ = new global::LotusIR.TensorProto();
        }
        Indices.MergeFrom(other.Indices);
      }
      if (other.values_ != null) {
        if (values_ == null) {
          values_ = new global::LotusIR.TensorProto();
        }
        Values.MergeFrom(other.Values);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10:
          case 8: {
            dims_.AddEntriesFrom(input, _repeated_dims_codec);
            break;
          }
          case 18: {
            if (indices_ == null) {
              indices_ = new global::LotusIR.TensorProto();
            }
            input.ReadMessage(indices_);
            break;
          }
          case 26: {
            if (values_ == null) {
              values_ = new global::LotusIR.TensorProto();
            }
            input.ReadMessage(values_);
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Define the types.
  /// </summary>
  public sealed partial class TypeProto : pb::IMessage<TypeProto> {
    private static readonly pb::MessageParser<TypeProto> _parser = new pb::MessageParser<TypeProto>(() => new TypeProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<TypeProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[7]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeProto(TypeProto other) : this() {
      switch (other.ValueCase) {
        case ValueOneofCase.TensorType:
          TensorType = other.TensorType.Clone();
          break;
        case ValueOneofCase.SparseTensorType:
          SparseTensorType = other.SparseTensorType.Clone();
          break;
        case ValueOneofCase.HandleType:
          HandleType = other.HandleType.Clone();
          break;
        case ValueOneofCase.TupleType:
          TupleType = other.TupleType.Clone();
          break;
        case ValueOneofCase.SeqType:
          SeqType = other.SeqType.Clone();
          break;
        case ValueOneofCase.MapType:
          MapType = other.MapType.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public TypeProto Clone() {
      return new TypeProto(this);
    }

    /// <summary>Field number for the "tensor_type" field.</summary>
    public const int TensorTypeFieldNumber = 1;
    /// <summary>
    /// The type of a tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TypeProto.Types.TensorTypeProto TensorType {
      get { return valueCase_ == ValueOneofCase.TensorType ? (global::LotusIR.TypeProto.Types.TensorTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.TensorType;
      }
    }

    /// <summary>Field number for the "sparse_tensor_type" field.</summary>
    public const int SparseTensorTypeFieldNumber = 2;
    /// <summary>
    /// The type of a sparse tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TypeProto.Types.SparseTensorTypeProto SparseTensorType {
      get { return valueCase_ == ValueOneofCase.SparseTensorType ? (global::LotusIR.TypeProto.Types.SparseTensorTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.SparseTensorType;
      }
    }

    /// <summary>Field number for the "handle_type" field.</summary>
    public const int HandleTypeFieldNumber = 3;
    /// <summary>
    /// The type of an opaque handle. A handle is used to represent a
    /// reference to a resource managed by the framework runtime.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TypeProto.Types.HandleTypeProto HandleType {
      get { return valueCase_ == ValueOneofCase.HandleType ? (global::LotusIR.TypeProto.Types.HandleTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.HandleType;
      }
    }

    /// <summary>Field number for the "tuple_type" field.</summary>
    public const int TupleTypeFieldNumber = 4;
    /// <summary>
    /// The type of a tuple.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TypeProto.Types.TupleTypeProto TupleType {
      get { return valueCase_ == ValueOneofCase.TupleType ? (global::LotusIR.TypeProto.Types.TupleTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.TupleType;
      }
    }

    /// <summary>Field number for the "seq_type" field.</summary>
    public const int SeqTypeFieldNumber = 5;
    /// <summary>
    /// The type of a sequence.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TypeProto.Types.SeqTypeProto SeqType {
      get { return valueCase_ == ValueOneofCase.SeqType ? (global::LotusIR.TypeProto.Types.SeqTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.SeqType;
      }
    }

    /// <summary>Field number for the "map_type" field.</summary>
    public const int MapTypeFieldNumber = 6;
    /// <summary>
    /// The type of a map.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TypeProto.Types.MapTypeProto MapType {
      get { return valueCase_ == ValueOneofCase.MapType ? (global::LotusIR.TypeProto.Types.MapTypeProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.MapType;
      }
    }

    private object value_;
    /// <summary>Enum of possible cases for the "value" oneof.</summary>
    public enum ValueOneofCase {
      None = 0,
      TensorType = 1,
      SparseTensorType = 2,
      HandleType = 3,
      TupleType = 4,
      SeqType = 5,
      MapType = 6,
    }
    private ValueOneofCase valueCase_ = ValueOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueOneofCase ValueCase {
      get { return valueCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValue() {
      valueCase_ = ValueOneofCase.None;
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as TypeProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(TypeProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(TensorType, other.TensorType)) return false;
      if (!object.Equals(SparseTensorType, other.SparseTensorType)) return false;
      if (!object.Equals(HandleType, other.HandleType)) return false;
      if (!object.Equals(TupleType, other.TupleType)) return false;
      if (!object.Equals(SeqType, other.SeqType)) return false;
      if (!object.Equals(MapType, other.MapType)) return false;
      if (ValueCase != other.ValueCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (valueCase_ == ValueOneofCase.TensorType) hash ^= TensorType.GetHashCode();
      if (valueCase_ == ValueOneofCase.SparseTensorType) hash ^= SparseTensorType.GetHashCode();
      if (valueCase_ == ValueOneofCase.HandleType) hash ^= HandleType.GetHashCode();
      if (valueCase_ == ValueOneofCase.TupleType) hash ^= TupleType.GetHashCode();
      if (valueCase_ == ValueOneofCase.SeqType) hash ^= SeqType.GetHashCode();
      if (valueCase_ == ValueOneofCase.MapType) hash ^= MapType.GetHashCode();
      hash ^= (int) valueCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (valueCase_ == ValueOneofCase.TensorType) {
        output.WriteRawTag(10);
        output.WriteMessage(TensorType);
      }
      if (valueCase_ == ValueOneofCase.SparseTensorType) {
        output.WriteRawTag(18);
        output.WriteMessage(SparseTensorType);
      }
      if (valueCase_ == ValueOneofCase.HandleType) {
        output.WriteRawTag(26);
        output.WriteMessage(HandleType);
      }
      if (valueCase_ == ValueOneofCase.TupleType) {
        output.WriteRawTag(34);
        output.WriteMessage(TupleType);
      }
      if (valueCase_ == ValueOneofCase.SeqType) {
        output.WriteRawTag(42);
        output.WriteMessage(SeqType);
      }
      if (valueCase_ == ValueOneofCase.MapType) {
        output.WriteRawTag(50);
        output.WriteMessage(MapType);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (valueCase_ == ValueOneofCase.TensorType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TensorType);
      }
      if (valueCase_ == ValueOneofCase.SparseTensorType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SparseTensorType);
      }
      if (valueCase_ == ValueOneofCase.HandleType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(HandleType);
      }
      if (valueCase_ == ValueOneofCase.TupleType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(TupleType);
      }
      if (valueCase_ == ValueOneofCase.SeqType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SeqType);
      }
      if (valueCase_ == ValueOneofCase.MapType) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(MapType);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(TypeProto other) {
      if (other == null) {
        return;
      }
      switch (other.ValueCase) {
        case ValueOneofCase.TensorType:
          TensorType = other.TensorType;
          break;
        case ValueOneofCase.SparseTensorType:
          SparseTensorType = other.SparseTensorType;
          break;
        case ValueOneofCase.HandleType:
          HandleType = other.HandleType;
          break;
        case ValueOneofCase.TupleType:
          TupleType = other.TupleType;
          break;
        case ValueOneofCase.SeqType:
          SeqType = other.SeqType;
          break;
        case ValueOneofCase.MapType:
          MapType = other.MapType;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            global::LotusIR.TypeProto.Types.TensorTypeProto subBuilder = new global::LotusIR.TypeProto.Types.TensorTypeProto();
            if (valueCase_ == ValueOneofCase.TensorType) {
              subBuilder.MergeFrom(TensorType);
            }
            input.ReadMessage(subBuilder);
            TensorType = subBuilder;
            break;
          }
          case 18: {
            global::LotusIR.TypeProto.Types.SparseTensorTypeProto subBuilder = new global::LotusIR.TypeProto.Types.SparseTensorTypeProto();
            if (valueCase_ == ValueOneofCase.SparseTensorType) {
              subBuilder.MergeFrom(SparseTensorType);
            }
            input.ReadMessage(subBuilder);
            SparseTensorType = subBuilder;
            break;
          }
          case 26: {
            global::LotusIR.TypeProto.Types.HandleTypeProto subBuilder = new global::LotusIR.TypeProto.Types.HandleTypeProto();
            if (valueCase_ == ValueOneofCase.HandleType) {
              subBuilder.MergeFrom(HandleType);
            }
            input.ReadMessage(subBuilder);
            HandleType = subBuilder;
            break;
          }
          case 34: {
            global::LotusIR.TypeProto.Types.TupleTypeProto subBuilder = new global::LotusIR.TypeProto.Types.TupleTypeProto();
            if (valueCase_ == ValueOneofCase.TupleType) {
              subBuilder.MergeFrom(TupleType);
            }
            input.ReadMessage(subBuilder);
            TupleType = subBuilder;
            break;
          }
          case 42: {
            global::LotusIR.TypeProto.Types.SeqTypeProto subBuilder = new global::LotusIR.TypeProto.Types.SeqTypeProto();
            if (valueCase_ == ValueOneofCase.SeqType) {
              subBuilder.MergeFrom(SeqType);
            }
            input.ReadMessage(subBuilder);
            SeqType = subBuilder;
            break;
          }
          case 50: {
            global::LotusIR.TypeProto.Types.MapTypeProto subBuilder = new global::LotusIR.TypeProto.Types.MapTypeProto();
            if (valueCase_ == ValueOneofCase.MapType) {
              subBuilder.MergeFrom(MapType);
            }
            input.ReadMessage(subBuilder);
            MapType = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the TypeProto message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Defines a tensor shape. A dimension can be either an integer value
      /// or a symbolic variable. A symbolic variable represents an unknown
      /// dimension.
      /// </summary>
      public sealed partial class TensorShapeProto : pb::IMessage<TensorShapeProto> {
        private static readonly pb::MessageParser<TensorShapeProto> _parser = new pb::MessageParser<TensorShapeProto>(() => new TensorShapeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TensorShapeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.TypeProto.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorShapeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorShapeProto(TensorShapeProto other) : this() {
          dim_ = other.dim_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorShapeProto Clone() {
          return new TensorShapeProto(this);
        }

        /// <summary>Field number for the "dim" field.</summary>
        public const int DimFieldNumber = 1;
        private static readonly pb::FieldCodec<global::LotusIR.TypeProto.Types.TensorShapeProto.Types.Dimension> _repeated_dim_codec
            = pb::FieldCodec.ForMessage(10, global::LotusIR.TypeProto.Types.TensorShapeProto.Types.Dimension.Parser);
        private readonly pbc::RepeatedField<global::LotusIR.TypeProto.Types.TensorShapeProto.Types.Dimension> dim_ = new pbc::RepeatedField<global::LotusIR.TypeProto.Types.TensorShapeProto.Types.Dimension>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::LotusIR.TypeProto.Types.TensorShapeProto.Types.Dimension> Dim {
          get { return dim_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TensorShapeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TensorShapeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!dim_.Equals(other.dim_)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= dim_.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          dim_.WriteTo(output, _repeated_dim_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += dim_.CalculateSize(_repeated_dim_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TensorShapeProto other) {
          if (other == null) {
            return;
          }
          dim_.Add(other.dim_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                dim_.AddEntriesFrom(input, _repeated_dim_codec);
                break;
              }
            }
          }
        }

        #region Nested types
        /// <summary>Container for nested types declared in the TensorShapeProto message type.</summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static partial class Types {
          public sealed partial class Dimension : pb::IMessage<Dimension> {
            private static readonly pb::MessageParser<Dimension> _parser = new pb::MessageParser<Dimension>(() => new Dimension());
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pb::MessageParser<Dimension> Parser { get { return _parser; } }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public static pbr::MessageDescriptor Descriptor {
              get { return global::LotusIR.TypeProto.Types.TensorShapeProto.Descriptor.NestedTypes[0]; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            pbr::MessageDescriptor pb::IMessage.Descriptor {
              get { return Descriptor; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Dimension() {
              OnConstruction();
            }

            partial void OnConstruction();

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Dimension(Dimension other) : this() {
              switch (other.ValueCase) {
                case ValueOneofCase.DimValue:
                  DimValue = other.DimValue;
                  break;
                case ValueOneofCase.DimParam:
                  DimParam = other.DimParam;
                  break;
              }

            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public Dimension Clone() {
              return new Dimension(this);
            }

            /// <summary>Field number for the "dim_value" field.</summary>
            public const int DimValueFieldNumber = 1;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public long DimValue {
              get { return valueCase_ == ValueOneofCase.DimValue ? (long) value_ : 0L; }
              set {
                value_ = value;
                valueCase_ = ValueOneofCase.DimValue;
              }
            }

            /// <summary>Field number for the "dim_param" field.</summary>
            public const int DimParamFieldNumber = 2;
            /// <summary>
            /// namespace Shape
            /// </summary>
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public string DimParam {
              get { return valueCase_ == ValueOneofCase.DimParam ? (string) value_ : ""; }
              set {
                value_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
                valueCase_ = ValueOneofCase.DimParam;
              }
            }

            private object value_;
            /// <summary>Enum of possible cases for the "value" oneof.</summary>
            public enum ValueOneofCase {
              None = 0,
              DimValue = 1,
              DimParam = 2,
            }
            private ValueOneofCase valueCase_ = ValueOneofCase.None;
            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public ValueOneofCase ValueCase {
              get { return valueCase_; }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void ClearValue() {
              valueCase_ = ValueOneofCase.None;
              value_ = null;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override bool Equals(object other) {
              return Equals(other as Dimension);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public bool Equals(Dimension other) {
              if (ReferenceEquals(other, null)) {
                return false;
              }
              if (ReferenceEquals(other, this)) {
                return true;
              }
              if (DimValue != other.DimValue) return false;
              if (DimParam != other.DimParam) return false;
              if (ValueCase != other.ValueCase) return false;
              return true;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override int GetHashCode() {
              int hash = 1;
              if (valueCase_ == ValueOneofCase.DimValue) hash ^= DimValue.GetHashCode();
              if (valueCase_ == ValueOneofCase.DimParam) hash ^= DimParam.GetHashCode();
              hash ^= (int) valueCase_;
              return hash;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public override string ToString() {
              return pb::JsonFormatter.ToDiagnosticString(this);
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void WriteTo(pb::CodedOutputStream output) {
              if (valueCase_ == ValueOneofCase.DimValue) {
                output.WriteRawTag(8);
                output.WriteInt64(DimValue);
              }
              if (valueCase_ == ValueOneofCase.DimParam) {
                output.WriteRawTag(18);
                output.WriteString(DimParam);
              }
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public int CalculateSize() {
              int size = 0;
              if (valueCase_ == ValueOneofCase.DimValue) {
                size += 1 + pb::CodedOutputStream.ComputeInt64Size(DimValue);
              }
              if (valueCase_ == ValueOneofCase.DimParam) {
                size += 1 + pb::CodedOutputStream.ComputeStringSize(DimParam);
              }
              return size;
            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(Dimension other) {
              if (other == null) {
                return;
              }
              switch (other.ValueCase) {
                case ValueOneofCase.DimValue:
                  DimValue = other.DimValue;
                  break;
                case ValueOneofCase.DimParam:
                  DimParam = other.DimParam;
                  break;
              }

            }

            [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
            public void MergeFrom(pb::CodedInputStream input) {
              uint tag;
              while ((tag = input.ReadTag()) != 0) {
                switch(tag) {
                  default:
                    input.SkipLastField();
                    break;
                  case 8: {
                    DimValue = input.ReadInt64();
                    break;
                  }
                  case 18: {
                    DimParam = input.ReadString();
                    break;
                  }
                }
              }
            }

          }

        }
        #endregion

      }

      public sealed partial class TensorTypeProto : pb::IMessage<TensorTypeProto> {
        private static readonly pb::MessageParser<TensorTypeProto> _parser = new pb::MessageParser<TensorTypeProto>(() => new TensorTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TensorTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.TypeProto.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorTypeProto(TensorTypeProto other) : this() {
          elemType_ = other.elemType_;
          Shape = other.shape_ != null ? other.Shape.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TensorTypeProto Clone() {
          return new TensorTypeProto(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private global::LotusIR.TensorProto.Types.DataType elemType_ = 0;
        /// <summary>
        /// This field MUST NOT have the value of UNDEFINED
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusIR.TensorProto.Types.DataType ElemType {
          get { return elemType_; }
          set {
            elemType_ = value;
          }
        }

        /// <summary>Field number for the "shape" field.</summary>
        public const int ShapeFieldNumber = 2;
        private global::LotusIR.TypeProto.Types.TensorShapeProto shape_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusIR.TypeProto.Types.TensorShapeProto Shape {
          get { return shape_; }
          set {
            shape_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TensorTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TensorTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ElemType != other.ElemType) return false;
          if (!object.Equals(Shape, other.Shape)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (ElemType != 0) hash ^= ElemType.GetHashCode();
          if (shape_ != null) hash ^= Shape.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (ElemType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) ElemType);
          }
          if (shape_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Shape);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (ElemType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ElemType);
          }
          if (shape_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Shape);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TensorTypeProto other) {
          if (other == null) {
            return;
          }
          if (other.ElemType != 0) {
            ElemType = other.ElemType;
          }
          if (other.shape_ != null) {
            if (shape_ == null) {
              shape_ = new global::LotusIR.TypeProto.Types.TensorShapeProto();
            }
            Shape.MergeFrom(other.Shape);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                elemType_ = (global::LotusIR.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
              case 18: {
                if (shape_ == null) {
                  shape_ = new global::LotusIR.TypeProto.Types.TensorShapeProto();
                }
                input.ReadMessage(shape_);
                break;
              }
            }
          }
        }

      }

      public sealed partial class SparseTensorTypeProto : pb::IMessage<SparseTensorTypeProto> {
        private static readonly pb::MessageParser<SparseTensorTypeProto> _parser = new pb::MessageParser<SparseTensorTypeProto>(() => new SparseTensorTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SparseTensorTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.TypeProto.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensorTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensorTypeProto(SparseTensorTypeProto other) : this() {
          elemType_ = other.elemType_;
          Shape = other.shape_ != null ? other.Shape.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SparseTensorTypeProto Clone() {
          return new SparseTensorTypeProto(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private global::LotusIR.TensorProto.Types.DataType elemType_ = 0;
        /// <summary>
        /// This field MUST NOT have the value of UNDEFINED
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusIR.TensorProto.Types.DataType ElemType {
          get { return elemType_; }
          set {
            elemType_ = value;
          }
        }

        /// <summary>Field number for the "shape" field.</summary>
        public const int ShapeFieldNumber = 2;
        private global::LotusIR.TypeProto.Types.TensorShapeProto shape_;
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusIR.TypeProto.Types.TensorShapeProto Shape {
          get { return shape_; }
          set {
            shape_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SparseTensorTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SparseTensorTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (ElemType != other.ElemType) return false;
          if (!object.Equals(Shape, other.Shape)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (ElemType != 0) hash ^= ElemType.GetHashCode();
          if (shape_ != null) hash ^= Shape.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (ElemType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) ElemType);
          }
          if (shape_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Shape);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (ElemType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ElemType);
          }
          if (shape_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Shape);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SparseTensorTypeProto other) {
          if (other == null) {
            return;
          }
          if (other.ElemType != 0) {
            ElemType = other.ElemType;
          }
          if (other.shape_ != null) {
            if (shape_ == null) {
              shape_ = new global::LotusIR.TypeProto.Types.TensorShapeProto();
            }
            Shape.MergeFrom(other.Shape);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                elemType_ = (global::LotusIR.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
              case 18: {
                if (shape_ == null) {
                  shape_ = new global::LotusIR.TypeProto.Types.TensorShapeProto();
                }
                input.ReadMessage(shape_);
                break;
              }
            }
          }
        }

      }

      public sealed partial class HandleTypeProto : pb::IMessage<HandleTypeProto> {
        private static readonly pb::MessageParser<HandleTypeProto> _parser = new pb::MessageParser<HandleTypeProto>(() => new HandleTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<HandleTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.TypeProto.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HandleTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HandleTypeProto(HandleTypeProto other) : this() {
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HandleTypeProto Clone() {
          return new HandleTypeProto(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as HandleTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(HandleTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(HandleTypeProto other) {
          if (other == null) {
            return;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
            }
          }
        }

      }

      public sealed partial class TupleTypeProto : pb::IMessage<TupleTypeProto> {
        private static readonly pb::MessageParser<TupleTypeProto> _parser = new pb::MessageParser<TupleTypeProto>(() => new TupleTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TupleTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.TypeProto.Descriptor.NestedTypes[4]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleTypeProto(TupleTypeProto other) : this() {
          elemType_ = other.elemType_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleTypeProto Clone() {
          return new TupleTypeProto(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private static readonly pb::FieldCodec<global::LotusIR.TypeProto> _repeated_elemType_codec
            = pb::FieldCodec.ForMessage(10, global::LotusIR.TypeProto.Parser);
        private readonly pbc::RepeatedField<global::LotusIR.TypeProto> elemType_ = new pbc::RepeatedField<global::LotusIR.TypeProto>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::LotusIR.TypeProto> ElemType {
          get { return elemType_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TupleTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TupleTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!elemType_.Equals(other.elemType_)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= elemType_.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          elemType_.WriteTo(output, _repeated_elemType_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += elemType_.CalculateSize(_repeated_elemType_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TupleTypeProto other) {
          if (other == null) {
            return;
          }
          elemType_.Add(other.elemType_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                elemType_.AddEntriesFrom(input, _repeated_elemType_codec);
                break;
              }
            }
          }
        }

      }

      public sealed partial class SeqTypeProto : pb::IMessage<SeqTypeProto> {
        private static readonly pb::MessageParser<SeqTypeProto> _parser = new pb::MessageParser<SeqTypeProto>(() => new SeqTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SeqTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.TypeProto.Descriptor.NestedTypes[5]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SeqTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SeqTypeProto(SeqTypeProto other) : this() {
          ElemType = other.elemType_ != null ? other.ElemType.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SeqTypeProto Clone() {
          return new SeqTypeProto(this);
        }

        /// <summary>Field number for the "elem_type" field.</summary>
        public const int ElemTypeFieldNumber = 1;
        private global::LotusIR.TypeProto elemType_;
        /// <summary>
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusIR.TypeProto ElemType {
          get { return elemType_; }
          set {
            elemType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SeqTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SeqTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(ElemType, other.ElemType)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (elemType_ != null) hash ^= ElemType.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (elemType_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(ElemType);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (elemType_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(ElemType);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SeqTypeProto other) {
          if (other == null) {
            return;
          }
          if (other.elemType_ != null) {
            if (elemType_ == null) {
              elemType_ = new global::LotusIR.TypeProto();
            }
            ElemType.MergeFrom(other.ElemType);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                if (elemType_ == null) {
                  elemType_ = new global::LotusIR.TypeProto();
                }
                input.ReadMessage(elemType_);
                break;
              }
            }
          }
        }

      }

      public sealed partial class MapTypeProto : pb::IMessage<MapTypeProto> {
        private static readonly pb::MessageParser<MapTypeProto> _parser = new pb::MessageParser<MapTypeProto>(() => new MapTypeProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MapTypeProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.TypeProto.Descriptor.NestedTypes[6]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapTypeProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapTypeProto(MapTypeProto other) : this() {
          keyType_ = other.keyType_;
          valueType_ = other.valueType_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapTypeProto Clone() {
          return new MapTypeProto(this);
        }

        /// <summary>Field number for the "key_type" field.</summary>
        public const int KeyTypeFieldNumber = 1;
        private global::LotusIR.TensorProto.Types.DataType keyType_ = 0;
        /// <summary>
        /// This field MUST be present for this version of the IR.
        /// This field MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusIR.TensorProto.Types.DataType KeyType {
          get { return keyType_; }
          set {
            keyType_ = value;
          }
        }

        /// <summary>Field number for the "value_type" field.</summary>
        public const int ValueTypeFieldNumber = 2;
        private global::LotusIR.TensorProto.Types.DataType valueType_ = 0;
        /// <summary>
        /// This field MUST be present for this version of the IR.
        /// This field MUST NOT refer to UNDEFINED
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusIR.TensorProto.Types.DataType ValueType {
          get { return valueType_; }
          set {
            valueType_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as MapTypeProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MapTypeProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (KeyType != other.KeyType) return false;
          if (ValueType != other.ValueType) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (KeyType != 0) hash ^= KeyType.GetHashCode();
          if (ValueType != 0) hash ^= ValueType.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (KeyType != 0) {
            output.WriteRawTag(8);
            output.WriteEnum((int) KeyType);
          }
          if (ValueType != 0) {
            output.WriteRawTag(16);
            output.WriteEnum((int) ValueType);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (KeyType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) KeyType);
          }
          if (ValueType != 0) {
            size += 1 + pb::CodedOutputStream.ComputeEnumSize((int) ValueType);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MapTypeProto other) {
          if (other == null) {
            return;
          }
          if (other.KeyType != 0) {
            KeyType = other.KeyType;
          }
          if (other.ValueType != 0) {
            ValueType = other.ValueType;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                keyType_ = (global::LotusIR.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
              case 16: {
                valueType_ = (global::LotusIR.TensorProto.Types.DataType) input.ReadEnum();
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class ValueProto : pb::IMessage<ValueProto> {
    private static readonly pb::MessageParser<ValueProto> _parser = new pb::MessageParser<ValueProto>(() => new ValueProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ValueProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[8]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueProto(ValueProto other) : this() {
      switch (other.ValueCase) {
        case ValueOneofCase.DenseTensor:
          DenseTensor = other.DenseTensor.Clone();
          break;
        case ValueOneofCase.SparseTensor:
          SparseTensor = other.SparseTensor.Clone();
          break;
        case ValueOneofCase.Handle:
          Handle = other.Handle.Clone();
          break;
        case ValueOneofCase.Tuple:
          Tuple = other.Tuple.Clone();
          break;
        case ValueOneofCase.Seq:
          Seq = other.Seq.Clone();
          break;
        case ValueOneofCase.Map:
          Map = other.Map.Clone();
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueProto Clone() {
      return new ValueProto(this);
    }

    /// <summary>Field number for the "dense_tensor" field.</summary>
    public const int DenseTensorFieldNumber = 1;
    /// <summary>
    /// A dense tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TensorProto DenseTensor {
      get { return valueCase_ == ValueOneofCase.DenseTensor ? (global::LotusIR.TensorProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.DenseTensor;
      }
    }

    /// <summary>Field number for the "sparse_tensor" field.</summary>
    public const int SparseTensorFieldNumber = 2;
    /// <summary>
    /// A sparse tensor.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.SparseTensorProto SparseTensor {
      get { return valueCase_ == ValueOneofCase.SparseTensor ? (global::LotusIR.SparseTensorProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.SparseTensor;
      }
    }

    /// <summary>Field number for the "handle" field.</summary>
    public const int HandleFieldNumber = 3;
    /// <summary>
    /// A handle.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.ValueProto.Types.HandleProto Handle {
      get { return valueCase_ == ValueOneofCase.Handle ? (global::LotusIR.ValueProto.Types.HandleProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.Handle;
      }
    }

    /// <summary>Field number for the "tuple" field.</summary>
    public const int TupleFieldNumber = 4;
    /// <summary>
    /// A tuple.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.ValueProto.Types.TupleProto Tuple {
      get { return valueCase_ == ValueOneofCase.Tuple ? (global::LotusIR.ValueProto.Types.TupleProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.Tuple;
      }
    }

    /// <summary>Field number for the "seq" field.</summary>
    public const int SeqFieldNumber = 5;
    /// <summary>
    /// A sequence.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.ValueProto.Types.SequenceProto Seq {
      get { return valueCase_ == ValueOneofCase.Seq ? (global::LotusIR.ValueProto.Types.SequenceProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.Seq;
      }
    }

    /// <summary>Field number for the "map" field.</summary>
    public const int MapFieldNumber = 6;
    /// <summary>
    /// A map.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.ValueProto.Types.MapProto Map {
      get { return valueCase_ == ValueOneofCase.Map ? (global::LotusIR.ValueProto.Types.MapProto) value_ : null; }
      set {
        value_ = value;
        valueCase_ = value == null ? ValueOneofCase.None : ValueOneofCase.Map;
      }
    }

    private object value_;
    /// <summary>Enum of possible cases for the "value" oneof.</summary>
    public enum ValueOneofCase {
      None = 0,
      DenseTensor = 1,
      SparseTensor = 2,
      Handle = 3,
      Tuple = 4,
      Seq = 5,
      Map = 6,
    }
    private ValueOneofCase valueCase_ = ValueOneofCase.None;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ValueOneofCase ValueCase {
      get { return valueCase_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void ClearValue() {
      valueCase_ = ValueOneofCase.None;
      value_ = null;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ValueProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ValueProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (!object.Equals(DenseTensor, other.DenseTensor)) return false;
      if (!object.Equals(SparseTensor, other.SparseTensor)) return false;
      if (!object.Equals(Handle, other.Handle)) return false;
      if (!object.Equals(Tuple, other.Tuple)) return false;
      if (!object.Equals(Seq, other.Seq)) return false;
      if (!object.Equals(Map, other.Map)) return false;
      if (ValueCase != other.ValueCase) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (valueCase_ == ValueOneofCase.DenseTensor) hash ^= DenseTensor.GetHashCode();
      if (valueCase_ == ValueOneofCase.SparseTensor) hash ^= SparseTensor.GetHashCode();
      if (valueCase_ == ValueOneofCase.Handle) hash ^= Handle.GetHashCode();
      if (valueCase_ == ValueOneofCase.Tuple) hash ^= Tuple.GetHashCode();
      if (valueCase_ == ValueOneofCase.Seq) hash ^= Seq.GetHashCode();
      if (valueCase_ == ValueOneofCase.Map) hash ^= Map.GetHashCode();
      hash ^= (int) valueCase_;
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (valueCase_ == ValueOneofCase.DenseTensor) {
        output.WriteRawTag(10);
        output.WriteMessage(DenseTensor);
      }
      if (valueCase_ == ValueOneofCase.SparseTensor) {
        output.WriteRawTag(18);
        output.WriteMessage(SparseTensor);
      }
      if (valueCase_ == ValueOneofCase.Handle) {
        output.WriteRawTag(26);
        output.WriteMessage(Handle);
      }
      if (valueCase_ == ValueOneofCase.Tuple) {
        output.WriteRawTag(34);
        output.WriteMessage(Tuple);
      }
      if (valueCase_ == ValueOneofCase.Seq) {
        output.WriteRawTag(42);
        output.WriteMessage(Seq);
      }
      if (valueCase_ == ValueOneofCase.Map) {
        output.WriteRawTag(50);
        output.WriteMessage(Map);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (valueCase_ == ValueOneofCase.DenseTensor) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(DenseTensor);
      }
      if (valueCase_ == ValueOneofCase.SparseTensor) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(SparseTensor);
      }
      if (valueCase_ == ValueOneofCase.Handle) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Handle);
      }
      if (valueCase_ == ValueOneofCase.Tuple) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Tuple);
      }
      if (valueCase_ == ValueOneofCase.Seq) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Seq);
      }
      if (valueCase_ == ValueOneofCase.Map) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Map);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ValueProto other) {
      if (other == null) {
        return;
      }
      switch (other.ValueCase) {
        case ValueOneofCase.DenseTensor:
          DenseTensor = other.DenseTensor;
          break;
        case ValueOneofCase.SparseTensor:
          SparseTensor = other.SparseTensor;
          break;
        case ValueOneofCase.Handle:
          Handle = other.Handle;
          break;
        case ValueOneofCase.Tuple:
          Tuple = other.Tuple;
          break;
        case ValueOneofCase.Seq:
          Seq = other.Seq;
          break;
        case ValueOneofCase.Map:
          Map = other.Map;
          break;
      }

    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            global::LotusIR.TensorProto subBuilder = new global::LotusIR.TensorProto();
            if (valueCase_ == ValueOneofCase.DenseTensor) {
              subBuilder.MergeFrom(DenseTensor);
            }
            input.ReadMessage(subBuilder);
            DenseTensor = subBuilder;
            break;
          }
          case 18: {
            global::LotusIR.SparseTensorProto subBuilder = new global::LotusIR.SparseTensorProto();
            if (valueCase_ == ValueOneofCase.SparseTensor) {
              subBuilder.MergeFrom(SparseTensor);
            }
            input.ReadMessage(subBuilder);
            SparseTensor = subBuilder;
            break;
          }
          case 26: {
            global::LotusIR.ValueProto.Types.HandleProto subBuilder = new global::LotusIR.ValueProto.Types.HandleProto();
            if (valueCase_ == ValueOneofCase.Handle) {
              subBuilder.MergeFrom(Handle);
            }
            input.ReadMessage(subBuilder);
            Handle = subBuilder;
            break;
          }
          case 34: {
            global::LotusIR.ValueProto.Types.TupleProto subBuilder = new global::LotusIR.ValueProto.Types.TupleProto();
            if (valueCase_ == ValueOneofCase.Tuple) {
              subBuilder.MergeFrom(Tuple);
            }
            input.ReadMessage(subBuilder);
            Tuple = subBuilder;
            break;
          }
          case 42: {
            global::LotusIR.ValueProto.Types.SequenceProto subBuilder = new global::LotusIR.ValueProto.Types.SequenceProto();
            if (valueCase_ == ValueOneofCase.Seq) {
              subBuilder.MergeFrom(Seq);
            }
            input.ReadMessage(subBuilder);
            Seq = subBuilder;
            break;
          }
          case 50: {
            global::LotusIR.ValueProto.Types.MapProto subBuilder = new global::LotusIR.ValueProto.Types.MapProto();
            if (valueCase_ == ValueOneofCase.Map) {
              subBuilder.MergeFrom(Map);
            }
            input.ReadMessage(subBuilder);
            Map = subBuilder;
            break;
          }
        }
      }
    }

    #region Nested types
    /// <summary>Container for nested types declared in the ValueProto message type.</summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static partial class Types {
      /// <summary>
      /// Defines a handle in its serialized format.
      /// </summary>
      public sealed partial class HandleProto : pb::IMessage<HandleProto> {
        private static readonly pb::MessageParser<HandleProto> _parser = new pb::MessageParser<HandleProto>(() => new HandleProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<HandleProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.ValueProto.Descriptor.NestedTypes[0]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HandleProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HandleProto(HandleProto other) : this() {
          uid_ = other.uid_;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public HandleProto Clone() {
          return new HandleProto(this);
        }

        /// <summary>Field number for the "uid" field.</summary>
        public const int UidFieldNumber = 1;
        private long uid_;
        /// <summary>
        /// This field MUST be present this version of the IR.  
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public long Uid {
          get { return uid_; }
          set {
            uid_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as HandleProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(HandleProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (Uid != other.Uid) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (Uid != 0L) hash ^= Uid.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (Uid != 0L) {
            output.WriteRawTag(8);
            output.WriteInt64(Uid);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (Uid != 0L) {
            size += 1 + pb::CodedOutputStream.ComputeInt64Size(Uid);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(HandleProto other) {
          if (other == null) {
            return;
          }
          if (other.Uid != 0L) {
            Uid = other.Uid;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 8: {
                Uid = input.ReadInt64();
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Defines a tuple in its serialized format.
      /// </summary>
      public sealed partial class TupleProto : pb::IMessage<TupleProto> {
        private static readonly pb::MessageParser<TupleProto> _parser = new pb::MessageParser<TupleProto>(() => new TupleProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<TupleProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.ValueProto.Descriptor.NestedTypes[1]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleProto(TupleProto other) : this() {
          elems_ = other.elems_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public TupleProto Clone() {
          return new TupleProto(this);
        }

        /// <summary>Field number for the "elems" field.</summary>
        public const int ElemsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::LotusIR.ValueProto> _repeated_elems_codec
            = pb::FieldCodec.ForMessage(10, global::LotusIR.ValueProto.Parser);
        private readonly pbc::RepeatedField<global::LotusIR.ValueProto> elems_ = new pbc::RepeatedField<global::LotusIR.ValueProto>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::LotusIR.ValueProto> Elems {
          get { return elems_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as TupleProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(TupleProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!elems_.Equals(other.elems_)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= elems_.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          elems_.WriteTo(output, _repeated_elems_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += elems_.CalculateSize(_repeated_elems_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(TupleProto other) {
          if (other == null) {
            return;
          }
          elems_.Add(other.elems_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                elems_.AddEntriesFrom(input, _repeated_elems_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Defines a sequence in its serialized format.
      /// </summary>
      public sealed partial class SequenceProto : pb::IMessage<SequenceProto> {
        private static readonly pb::MessageParser<SequenceProto> _parser = new pb::MessageParser<SequenceProto>(() => new SequenceProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<SequenceProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.ValueProto.Descriptor.NestedTypes[2]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SequenceProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SequenceProto(SequenceProto other) : this() {
          elems_ = other.elems_.Clone();
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public SequenceProto Clone() {
          return new SequenceProto(this);
        }

        /// <summary>Field number for the "elems" field.</summary>
        public const int ElemsFieldNumber = 1;
        private static readonly pb::FieldCodec<global::LotusIR.ValueProto> _repeated_elems_codec
            = pb::FieldCodec.ForMessage(10, global::LotusIR.ValueProto.Parser);
        private readonly pbc::RepeatedField<global::LotusIR.ValueProto> elems_ = new pbc::RepeatedField<global::LotusIR.ValueProto>();
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public pbc::RepeatedField<global::LotusIR.ValueProto> Elems {
          get { return elems_; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as SequenceProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(SequenceProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if(!elems_.Equals(other.elems_)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          hash ^= elems_.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          elems_.WriteTo(output, _repeated_elems_codec);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          size += elems_.CalculateSize(_repeated_elems_codec);
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(SequenceProto other) {
          if (other == null) {
            return;
          }
          elems_.Add(other.elems_);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                elems_.AddEntriesFrom(input, _repeated_elems_codec);
                break;
              }
            }
          }
        }

      }

      /// <summary>
      /// Defines a map in its serialized format.
      /// Maps are serialized as two single-dimensional tensors 
      /// for storage efficiency. The dimensions of each tensor MUST be identical
      /// and the key at position N corresponds to the value at position N.
      /// Keys SHOULD be unique. When a given key appears multiple times,
      /// the value that corresponds last occurance of the key is the value.
      /// This is consistent with protobuf3 encoding rules for map.
      /// </summary>
      public sealed partial class MapProto : pb::IMessage<MapProto> {
        private static readonly pb::MessageParser<MapProto> _parser = new pb::MessageParser<MapProto>(() => new MapProto());
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pb::MessageParser<MapProto> Parser { get { return _parser; } }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public static pbr::MessageDescriptor Descriptor {
          get { return global::LotusIR.ValueProto.Descriptor.NestedTypes[3]; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        pbr::MessageDescriptor pb::IMessage.Descriptor {
          get { return Descriptor; }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapProto() {
          OnConstruction();
        }

        partial void OnConstruction();

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapProto(MapProto other) : this() {
          Keys = other.keys_ != null ? other.Keys.Clone() : null;
          Values = other.values_ != null ? other.Values.Clone() : null;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public MapProto Clone() {
          return new MapProto(this);
        }

        /// <summary>Field number for the "keys" field.</summary>
        public const int KeysFieldNumber = 1;
        private global::LotusIR.TensorProto keys_;
        /// <summary>
        /// This field MUST be present for this version of the IR.
        /// The data type of the tensor MUST refer to an integral type ([U]INT{8|16|32|64}) or STRING
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusIR.TensorProto Keys {
          get { return keys_; }
          set {
            keys_ = value;
          }
        }

        /// <summary>Field number for the "values" field.</summary>
        public const int ValuesFieldNumber = 2;
        private global::LotusIR.TensorProto values_;
        /// <summary>
        /// This field MUST be present for this version of the IR.
        /// </summary>
        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public global::LotusIR.TensorProto Values {
          get { return values_; }
          set {
            values_ = value;
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override bool Equals(object other) {
          return Equals(other as MapProto);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public bool Equals(MapProto other) {
          if (ReferenceEquals(other, null)) {
            return false;
          }
          if (ReferenceEquals(other, this)) {
            return true;
          }
          if (!object.Equals(Keys, other.Keys)) return false;
          if (!object.Equals(Values, other.Values)) return false;
          return true;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override int GetHashCode() {
          int hash = 1;
          if (keys_ != null) hash ^= Keys.GetHashCode();
          if (values_ != null) hash ^= Values.GetHashCode();
          return hash;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public override string ToString() {
          return pb::JsonFormatter.ToDiagnosticString(this);
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void WriteTo(pb::CodedOutputStream output) {
          if (keys_ != null) {
            output.WriteRawTag(10);
            output.WriteMessage(Keys);
          }
          if (values_ != null) {
            output.WriteRawTag(18);
            output.WriteMessage(Values);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public int CalculateSize() {
          int size = 0;
          if (keys_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Keys);
          }
          if (values_ != null) {
            size += 1 + pb::CodedOutputStream.ComputeMessageSize(Values);
          }
          return size;
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(MapProto other) {
          if (other == null) {
            return;
          }
          if (other.keys_ != null) {
            if (keys_ == null) {
              keys_ = new global::LotusIR.TensorProto();
            }
            Keys.MergeFrom(other.Keys);
          }
          if (other.values_ != null) {
            if (values_ == null) {
              values_ = new global::LotusIR.TensorProto();
            }
            Values.MergeFrom(other.Values);
          }
        }

        [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
        public void MergeFrom(pb::CodedInputStream input) {
          uint tag;
          while ((tag = input.ReadTag()) != 0) {
            switch(tag) {
              default:
                input.SkipLastField();
                break;
              case 10: {
                if (keys_ == null) {
                  keys_ = new global::LotusIR.TensorProto();
                }
                input.ReadMessage(keys_);
                break;
              }
              case 18: {
                if (values_ == null) {
                  values_ = new global::LotusIR.TensorProto();
                }
                input.ReadMessage(values_);
                break;
              }
            }
          }
        }

      }

    }
    #endregion

  }

  public sealed partial class ParameterDeclProto : pb::IMessage<ParameterDeclProto> {
    private static readonly pb::MessageParser<ParameterDeclProto> _parser = new pb::MessageParser<ParameterDeclProto>(() => new ParameterDeclProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<ParameterDeclProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[9]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParameterDeclProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParameterDeclProto(ParameterDeclProto other) : this() {
      name_ = other.name_;
      Type = other.type_ != null ? other.Type.Clone() : null;
      docString_ = other.docString_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public ParameterDeclProto Clone() {
      return new ParameterDeclProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "type" field.</summary>
    public const int TypeFieldNumber = 2;
    private global::LotusIR.TypeProto type_;
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public global::LotusIR.TypeProto Type {
      get { return type_; }
      set {
        type_ = value;
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 3;
    private string docString_ = "";
    /// <summary>
    /// An  human-readable documentation for this parameter.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as ParameterDeclProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(ParameterDeclProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if (!object.Equals(Type, other.Type)) return false;
      if (DocString != other.DocString) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (type_ != null) hash ^= Type.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      if (type_ != null) {
        output.WriteRawTag(18);
        output.WriteMessage(Type);
      }
      if (DocString.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DocString);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (type_ != null) {
        size += 1 + pb::CodedOutputStream.ComputeMessageSize(Type);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(ParameterDeclProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.type_ != null) {
        if (type_ == null) {
          type_ = new global::LotusIR.TypeProto();
        }
        Type.MergeFrom(other.Type);
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            if (type_ == null) {
              type_ = new global::LotusIR.TypeProto();
            }
            input.ReadMessage(type_);
            break;
          }
          case 26: {
            DocString = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// Defines a function.
  /// </summary>
  public sealed partial class FunctionDefProto : pb::IMessage<FunctionDefProto> {
    private static readonly pb::MessageParser<FunctionDefProto> _parser = new pb::MessageParser<FunctionDefProto>(() => new FunctionDefProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<FunctionDefProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[10]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FunctionDefProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FunctionDefProto(FunctionDefProto other) : this() {
      name_ = other.name_;
      inputParams_ = other.inputParams_.Clone();
      outputParams_ = other.outputParams_.Clone();
      node_ = other.node_.Clone();
      attr_ = other.attr_.Clone();
      docString_ = other.docString_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public FunctionDefProto Clone() {
      return new FunctionDefProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// The name of the function.
    /// This field MUST be present for this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "input_params" field.</summary>
    public const int InputParamsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::LotusIR.ParameterDeclProto> _repeated_inputParams_codec
        = pb::FieldCodec.ForMessage(18, global::LotusIR.ParameterDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.ParameterDeclProto> inputParams_ = new pbc::RepeatedField<global::LotusIR.ParameterDeclProto>();
    /// <summary>
    /// The input parameters of the function.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.ParameterDeclProto> InputParams {
      get { return inputParams_; }
    }

    /// <summary>Field number for the "output_params" field.</summary>
    public const int OutputParamsFieldNumber = 3;
    private static readonly pb::FieldCodec<global::LotusIR.ParameterDeclProto> _repeated_outputParams_codec
        = pb::FieldCodec.ForMessage(26, global::LotusIR.ParameterDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.ParameterDeclProto> outputParams_ = new pbc::RepeatedField<global::LotusIR.ParameterDeclProto>();
    /// <summary>
    /// The output parameters of the function.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.ParameterDeclProto> OutputParams {
      get { return outputParams_; }
    }

    /// <summary>Field number for the "node" field.</summary>
    public const int NodeFieldNumber = 4;
    private static readonly pb::FieldCodec<global::LotusIR.NodeProto> _repeated_node_codec
        = pb::FieldCodec.ForMessage(34, global::LotusIR.NodeProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.NodeProto> node_ = new pbc::RepeatedField<global::LotusIR.NodeProto>();
    /// <summary>
    /// The body of the function.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.NodeProto> Node {
      get { return node_; }
    }

    /// <summary>Field number for the "attr" field.</summary>
    public const int AttrFieldNumber = 5;
    private static readonly pb::FieldCodec<global::LotusIR.AttributeProto> _repeated_attr_codec
        = pb::FieldCodec.ForMessage(42, global::LotusIR.AttributeProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.AttributeProto> attr_ = new pbc::RepeatedField<global::LotusIR.AttributeProto>();
    /// <summary>
    /// The named attributes of the function.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.AttributeProto> Attr {
      get { return attr_; }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 6;
    private string docString_ = "";
    /// <summary>
    /// An  human-readable documentation for this node in the graph.
    /// This text MAY contain Markdown markup that conforms to http://commonmark.org/. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as FunctionDefProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(FunctionDefProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!inputParams_.Equals(other.inputParams_)) return false;
      if(!outputParams_.Equals(other.outputParams_)) return false;
      if(!node_.Equals(other.node_)) return false;
      if(!attr_.Equals(other.attr_)) return false;
      if (DocString != other.DocString) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= inputParams_.GetHashCode();
      hash ^= outputParams_.GetHashCode();
      hash ^= node_.GetHashCode();
      hash ^= attr_.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      inputParams_.WriteTo(output, _repeated_inputParams_codec);
      outputParams_.WriteTo(output, _repeated_outputParams_codec);
      node_.WriteTo(output, _repeated_node_codec);
      attr_.WriteTo(output, _repeated_attr_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(DocString);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += inputParams_.CalculateSize(_repeated_inputParams_codec);
      size += outputParams_.CalculateSize(_repeated_outputParams_codec);
      size += node_.CalculateSize(_repeated_node_codec);
      size += attr_.CalculateSize(_repeated_attr_codec);
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(FunctionDefProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      inputParams_.Add(other.inputParams_);
      outputParams_.Add(other.outputParams_);
      node_.Add(other.node_);
      attr_.Add(other.attr_);
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            inputParams_.AddEntriesFrom(input, _repeated_inputParams_codec);
            break;
          }
          case 26: {
            outputParams_.AddEntriesFrom(input, _repeated_outputParams_codec);
            break;
          }
          case 34: {
            node_.AddEntriesFrom(input, _repeated_node_codec);
            break;
          }
          case 42: {
            attr_.AddEntriesFrom(input, _repeated_attr_codec);
            break;
          }
          case 50: {
            DocString = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class SignatureDeclProto : pb::IMessage<SignatureDeclProto> {
    private static readonly pb::MessageParser<SignatureDeclProto> _parser = new pb::MessageParser<SignatureDeclProto>(() => new SignatureDeclProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<SignatureDeclProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[11]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignatureDeclProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignatureDeclProto(SignatureDeclProto other) : this() {
      inputParams_ = other.inputParams_.Clone();
      outputParams_ = other.outputParams_.Clone();
      inputAttributes_ = other.inputAttributes_.Clone();
      docString_ = other.docString_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public SignatureDeclProto Clone() {
      return new SignatureDeclProto(this);
    }

    /// <summary>Field number for the "input_params" field.</summary>
    public const int InputParamsFieldNumber = 1;
    private static readonly pb::FieldCodec<global::LotusIR.ParameterDeclProto> _repeated_inputParams_codec
        = pb::FieldCodec.ForMessage(10, global::LotusIR.ParameterDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.ParameterDeclProto> inputParams_ = new pbc::RepeatedField<global::LotusIR.ParameterDeclProto>();
    /// <summary>
    /// The formal input parameters to the operation or function 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.ParameterDeclProto> InputParams {
      get { return inputParams_; }
    }

    /// <summary>Field number for the "output_params" field.</summary>
    public const int OutputParamsFieldNumber = 2;
    private static readonly pb::FieldCodec<global::LotusIR.ParameterDeclProto> _repeated_outputParams_codec
        = pb::FieldCodec.ForMessage(18, global::LotusIR.ParameterDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.ParameterDeclProto> outputParams_ = new pbc::RepeatedField<global::LotusIR.ParameterDeclProto>();
    /// <summary>
    /// The formal output parameters to the operation or function 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.ParameterDeclProto> OutputParams {
      get { return outputParams_; }
    }

    /// <summary>Field number for the "input_attributes" field.</summary>
    public const int InputAttributesFieldNumber = 3;
    private static readonly pb::FieldCodec<global::LotusIR.ParameterDeclProto> _repeated_inputAttributes_codec
        = pb::FieldCodec.ForMessage(26, global::LotusIR.ParameterDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.ParameterDeclProto> inputAttributes_ = new pbc::RepeatedField<global::LotusIR.ParameterDeclProto>();
    /// <summary>
    /// The declaration of expected attributes to the operation or function 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.ParameterDeclProto> InputAttributes {
      get { return inputAttributes_; }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 4;
    private string docString_ = "";
    /// <summary>
    /// An  human-readable documentation for this signature.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as SignatureDeclProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(SignatureDeclProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if(!inputParams_.Equals(other.inputParams_)) return false;
      if(!outputParams_.Equals(other.outputParams_)) return false;
      if(!inputAttributes_.Equals(other.inputAttributes_)) return false;
      if (DocString != other.DocString) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      hash ^= inputParams_.GetHashCode();
      hash ^= outputParams_.GetHashCode();
      hash ^= inputAttributes_.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      inputParams_.WriteTo(output, _repeated_inputParams_codec);
      outputParams_.WriteTo(output, _repeated_outputParams_codec);
      inputAttributes_.WriteTo(output, _repeated_inputAttributes_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(34);
        output.WriteString(DocString);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      size += inputParams_.CalculateSize(_repeated_inputParams_codec);
      size += outputParams_.CalculateSize(_repeated_outputParams_codec);
      size += inputAttributes_.CalculateSize(_repeated_inputAttributes_codec);
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(SignatureDeclProto other) {
      if (other == null) {
        return;
      }
      inputParams_.Add(other.inputParams_);
      outputParams_.Add(other.outputParams_);
      inputAttributes_.Add(other.inputAttributes_);
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            inputParams_.AddEntriesFrom(input, _repeated_inputParams_codec);
            break;
          }
          case 18: {
            outputParams_.AddEntriesFrom(input, _repeated_outputParams_codec);
            break;
          }
          case 26: {
            inputAttributes_.AddEntriesFrom(input, _repeated_inputAttributes_codec);
            break;
          }
          case 34: {
            DocString = input.ReadString();
            break;
          }
        }
      }
    }

  }

  public sealed partial class OperatorDeclProto : pb::IMessage<OperatorDeclProto> {
    private static readonly pb::MessageParser<OperatorDeclProto> _parser = new pb::MessageParser<OperatorDeclProto>(() => new OperatorDeclProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<OperatorDeclProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[12]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorDeclProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorDeclProto(OperatorDeclProto other) : this() {
      name_ = other.name_;
      signature_ = other.signature_.Clone();
      docString_ = other.docString_;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public OperatorDeclProto Clone() {
      return new OperatorDeclProto(this);
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 1;
    private string name_ = "";
    /// <summary>
    /// This field MUST be present for this version of the IR.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "signature" field.</summary>
    public const int SignatureFieldNumber = 2;
    private static readonly pb::FieldCodec<global::LotusIR.SignatureDeclProto> _repeated_signature_codec
        = pb::FieldCodec.ForMessage(18, global::LotusIR.SignatureDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.SignatureDeclProto> signature_ = new pbc::RepeatedField<global::LotusIR.SignatureDeclProto>();
    /// <summary>
    /// This field MUST contain at least one SignatureDeclProto.
    /// This field MAY contain multiple SignatureDeclProtos, one 
    /// per type signature supported by this operator.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.SignatureDeclProto> Signature {
      get { return signature_; }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 3;
    private string docString_ = "";
    /// <summary>
    /// An  human-readable documentation for this operator.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as OperatorDeclProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(OperatorDeclProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (Name != other.Name) return false;
      if(!signature_.Equals(other.signature_)) return false;
      if (DocString != other.DocString) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      hash ^= signature_.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (Name.Length != 0) {
        output.WriteRawTag(10);
        output.WriteString(Name);
      }
      signature_.WriteTo(output, _repeated_signature_codec);
      if (DocString.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(DocString);
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      size += signature_.CalculateSize(_repeated_signature_codec);
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(OperatorDeclProto other) {
      if (other == null) {
        return;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      signature_.Add(other.signature_);
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 10: {
            Name = input.ReadString();
            break;
          }
          case 18: {
            signature_.AddEntriesFrom(input, _repeated_signature_codec);
            break;
          }
          case 26: {
            DocString = input.ReadString();
            break;
          }
        }
      }
    }

  }

  /// <summary>
  /// A library is a top-level format that contains the declaration
  /// of operators and the definition of functions. 
  /// </summary>
  public sealed partial class LibraryProto : pb::IMessage<LibraryProto> {
    private static readonly pb::MessageParser<LibraryProto> _parser = new pb::MessageParser<LibraryProto>(() => new LibraryProto());
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pb::MessageParser<LibraryProto> Parser { get { return _parser; } }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public static pbr::MessageDescriptor Descriptor {
      get { return global::LotusIR.GraphReflection.Descriptor.MessageTypes[13]; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    pbr::MessageDescriptor pb::IMessage.Descriptor {
      get { return Descriptor; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LibraryProto() {
      OnConstruction();
    }

    partial void OnConstruction();

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LibraryProto(LibraryProto other) : this() {
      irVersion_ = other.irVersion_;
      producerVersion_ = other.producerVersion_;
      producerTag_ = other.producerTag_;
      modelVersion_ = other.modelVersion_;
      modelAuthor_ = other.modelAuthor_;
      modelLicense_ = other.modelLicense_;
      name_ = other.name_;
      domain_ = other.domain_;
      docString_ = other.docString_;
      operator_ = other.operator_.Clone();
      function_ = other.function_.Clone();
      importedLibraries_ = other.importedLibraries_.Clone();
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public LibraryProto Clone() {
      return new LibraryProto(this);
    }

    /// <summary>Field number for the "ir_version" field.</summary>
    public const int IrVersionFieldNumber = 1;
    private long irVersion_;
    /// <summary>
    /// The version of the IR this graph targets. See Version enum below.
    /// This field MUST be present this version of the IR.  
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long IrVersion {
      get { return irVersion_; }
      set {
        irVersion_ = value;
      }
    }

    /// <summary>Field number for the "producer_version" field.</summary>
    public const int ProducerVersionFieldNumber = 2;
    private long producerVersion_;
    /// <summary>
    /// The  version of the framework runtime that generates this graph.
    /// This producer_version has the same format as ir_version. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ProducerVersion {
      get { return producerVersion_; }
      set {
        producerVersion_ = value;
      }
    }

    /// <summary>Field number for the "producer_tag" field.</summary>
    public const int ProducerTagFieldNumber = 3;
    private string producerTag_ = "";
    /// <summary>
    /// The  name of the framework used to generate this graph in the form
    /// "framework_name[-tag]". Tag is  and provides additional
    /// information such as `alpha` or `beta` or `rc3`.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ProducerTag {
      get { return producerTag_; }
      set {
        producerTag_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_version" field.</summary>
    public const int ModelVersionFieldNumber = 4;
    private long modelVersion_;
    /// <summary>
    /// An  version identifier used to track evolution of this library.
    /// This model_version has the same format as ir_version. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public long ModelVersion {
      get { return modelVersion_; }
      set {
        modelVersion_ = value;
      }
    }

    /// <summary>Field number for the "model_author" field.</summary>
    public const int ModelAuthorFieldNumber = 5;
    private string modelAuthor_ = "";
    /// <summary>
    /// The  name of the author who created the library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelAuthor {
      get { return modelAuthor_; }
      set {
        modelAuthor_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "model_license" field.</summary>
    public const int ModelLicenseFieldNumber = 6;
    private string modelLicense_ = "";
    /// <summary>
    ///  licensing information concerning use or origination of the library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string ModelLicense {
      get { return modelLicense_; }
      set {
        modelLicense_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "name" field.</summary>
    public const int NameFieldNumber = 7;
    private string name_ = "";
    /// <summary>
    /// The name of the library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Name {
      get { return name_; }
      set {
        name_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "domain" field.</summary>
    public const int DomainFieldNumber = 8;
    private string domain_ = "";
    /// <summary>
    /// Domain of the graph.
    /// We use reverse domain names as name space indicators. For example:
    /// `com.facebook.fair` or `com.microsoft.cognitiveservices`
    ///
    /// Together with `name` and `model_version`, this forms the unique identity of
    /// the library.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string Domain {
      get { return domain_; }
      set {
        domain_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "doc_string" field.</summary>
    public const int DocStringFieldNumber = 9;
    private string docString_ = "";
    /// <summary>
    /// An  human-readable documentation for this graph.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public string DocString {
      get { return docString_; }
      set {
        docString_ = pb::ProtoPreconditions.CheckNotNull(value, "value");
      }
    }

    /// <summary>Field number for the "operator" field.</summary>
    public const int OperatorFieldNumber = 10;
    private static readonly pb::FieldCodec<global::LotusIR.OperatorDeclProto> _repeated_operator_codec
        = pb::FieldCodec.ForMessage(82, global::LotusIR.OperatorDeclProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.OperatorDeclProto> operator_ = new pbc::RepeatedField<global::LotusIR.OperatorDeclProto>();
    /// <summary>
    /// The operators declared by this library. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.OperatorDeclProto> Operator {
      get { return operator_; }
    }

    /// <summary>Field number for the "function" field.</summary>
    public const int FunctionFieldNumber = 11;
    private static readonly pb::FieldCodec<global::LotusIR.FunctionDefProto> _repeated_function_codec
        = pb::FieldCodec.ForMessage(90, global::LotusIR.FunctionDefProto.Parser);
    private readonly pbc::RepeatedField<global::LotusIR.FunctionDefProto> function_ = new pbc::RepeatedField<global::LotusIR.FunctionDefProto>();
    /// <summary>
    /// The function definitions of the library. 
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<global::LotusIR.FunctionDefProto> Function {
      get { return function_; }
    }

    /// <summary>Field number for the "imported_libraries" field.</summary>
    public const int ImportedLibrariesFieldNumber = 12;
    private static readonly pb::FieldCodec<string> _repeated_importedLibraries_codec
        = pb::FieldCodec.ForString(98);
    private readonly pbc::RepeatedField<string> importedLibraries_ = new pbc::RepeatedField<string>();
    /// <summary>
    /// Imported libraries are referenced as a collection of strings in the form of absolute
    /// URIs or relative paths. Where such relative paths are rooted is defined by tools and
    /// runtime implementations.
    /// </summary>
    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public pbc::RepeatedField<string> ImportedLibraries {
      get { return importedLibraries_; }
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override bool Equals(object other) {
      return Equals(other as LibraryProto);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public bool Equals(LibraryProto other) {
      if (ReferenceEquals(other, null)) {
        return false;
      }
      if (ReferenceEquals(other, this)) {
        return true;
      }
      if (IrVersion != other.IrVersion) return false;
      if (ProducerVersion != other.ProducerVersion) return false;
      if (ProducerTag != other.ProducerTag) return false;
      if (ModelVersion != other.ModelVersion) return false;
      if (ModelAuthor != other.ModelAuthor) return false;
      if (ModelLicense != other.ModelLicense) return false;
      if (Name != other.Name) return false;
      if (Domain != other.Domain) return false;
      if (DocString != other.DocString) return false;
      if(!operator_.Equals(other.operator_)) return false;
      if(!function_.Equals(other.function_)) return false;
      if(!importedLibraries_.Equals(other.importedLibraries_)) return false;
      return true;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override int GetHashCode() {
      int hash = 1;
      if (IrVersion != 0L) hash ^= IrVersion.GetHashCode();
      if (ProducerVersion != 0L) hash ^= ProducerVersion.GetHashCode();
      if (ProducerTag.Length != 0) hash ^= ProducerTag.GetHashCode();
      if (ModelVersion != 0L) hash ^= ModelVersion.GetHashCode();
      if (ModelAuthor.Length != 0) hash ^= ModelAuthor.GetHashCode();
      if (ModelLicense.Length != 0) hash ^= ModelLicense.GetHashCode();
      if (Name.Length != 0) hash ^= Name.GetHashCode();
      if (Domain.Length != 0) hash ^= Domain.GetHashCode();
      if (DocString.Length != 0) hash ^= DocString.GetHashCode();
      hash ^= operator_.GetHashCode();
      hash ^= function_.GetHashCode();
      hash ^= importedLibraries_.GetHashCode();
      return hash;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public override string ToString() {
      return pb::JsonFormatter.ToDiagnosticString(this);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void WriteTo(pb::CodedOutputStream output) {
      if (IrVersion != 0L) {
        output.WriteRawTag(8);
        output.WriteInt64(IrVersion);
      }
      if (ProducerVersion != 0L) {
        output.WriteRawTag(16);
        output.WriteInt64(ProducerVersion);
      }
      if (ProducerTag.Length != 0) {
        output.WriteRawTag(26);
        output.WriteString(ProducerTag);
      }
      if (ModelVersion != 0L) {
        output.WriteRawTag(32);
        output.WriteInt64(ModelVersion);
      }
      if (ModelAuthor.Length != 0) {
        output.WriteRawTag(42);
        output.WriteString(ModelAuthor);
      }
      if (ModelLicense.Length != 0) {
        output.WriteRawTag(50);
        output.WriteString(ModelLicense);
      }
      if (Name.Length != 0) {
        output.WriteRawTag(58);
        output.WriteString(Name);
      }
      if (Domain.Length != 0) {
        output.WriteRawTag(66);
        output.WriteString(Domain);
      }
      if (DocString.Length != 0) {
        output.WriteRawTag(74);
        output.WriteString(DocString);
      }
      operator_.WriteTo(output, _repeated_operator_codec);
      function_.WriteTo(output, _repeated_function_codec);
      importedLibraries_.WriteTo(output, _repeated_importedLibraries_codec);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public int CalculateSize() {
      int size = 0;
      if (IrVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(IrVersion);
      }
      if (ProducerVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ProducerVersion);
      }
      if (ProducerTag.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ProducerTag);
      }
      if (ModelVersion != 0L) {
        size += 1 + pb::CodedOutputStream.ComputeInt64Size(ModelVersion);
      }
      if (ModelAuthor.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelAuthor);
      }
      if (ModelLicense.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(ModelLicense);
      }
      if (Name.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Name);
      }
      if (Domain.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(Domain);
      }
      if (DocString.Length != 0) {
        size += 1 + pb::CodedOutputStream.ComputeStringSize(DocString);
      }
      size += operator_.CalculateSize(_repeated_operator_codec);
      size += function_.CalculateSize(_repeated_function_codec);
      size += importedLibraries_.CalculateSize(_repeated_importedLibraries_codec);
      return size;
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(LibraryProto other) {
      if (other == null) {
        return;
      }
      if (other.IrVersion != 0L) {
        IrVersion = other.IrVersion;
      }
      if (other.ProducerVersion != 0L) {
        ProducerVersion = other.ProducerVersion;
      }
      if (other.ProducerTag.Length != 0) {
        ProducerTag = other.ProducerTag;
      }
      if (other.ModelVersion != 0L) {
        ModelVersion = other.ModelVersion;
      }
      if (other.ModelAuthor.Length != 0) {
        ModelAuthor = other.ModelAuthor;
      }
      if (other.ModelLicense.Length != 0) {
        ModelLicense = other.ModelLicense;
      }
      if (other.Name.Length != 0) {
        Name = other.Name;
      }
      if (other.Domain.Length != 0) {
        Domain = other.Domain;
      }
      if (other.DocString.Length != 0) {
        DocString = other.DocString;
      }
      operator_.Add(other.operator_);
      function_.Add(other.function_);
      importedLibraries_.Add(other.importedLibraries_);
    }

    [global::System.Diagnostics.DebuggerNonUserCodeAttribute]
    public void MergeFrom(pb::CodedInputStream input) {
      uint tag;
      while ((tag = input.ReadTag()) != 0) {
        switch(tag) {
          default:
            input.SkipLastField();
            break;
          case 8: {
            IrVersion = input.ReadInt64();
            break;
          }
          case 16: {
            ProducerVersion = input.ReadInt64();
            break;
          }
          case 26: {
            ProducerTag = input.ReadString();
            break;
          }
          case 32: {
            ModelVersion = input.ReadInt64();
            break;
          }
          case 42: {
            ModelAuthor = input.ReadString();
            break;
          }
          case 50: {
            ModelLicense = input.ReadString();
            break;
          }
          case 58: {
            Name = input.ReadString();
            break;
          }
          case 66: {
            Domain = input.ReadString();
            break;
          }
          case 74: {
            DocString = input.ReadString();
            break;
          }
          case 82: {
            operator_.AddEntriesFrom(input, _repeated_operator_codec);
            break;
          }
          case 90: {
            function_.AddEntriesFrom(input, _repeated_function_codec);
            break;
          }
          case 98: {
            importedLibraries_.AddEntriesFrom(input, _repeated_importedLibraries_codec);
            break;
          }
        }
      }
    }

  }

  #endregion

}

#endregion Designer generated code
